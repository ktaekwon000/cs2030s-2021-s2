{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"CS2030S Programming Methodology II AY 2020/21 Semester 2 This website hosts the lecture notes, lecture slides, and other written guides about CS2030S. You can explore the links on the menu on the left, or search for keywords in the search bar above. Other Critical Web Resources Piazza for Q&A and discussions LumiNUS for all other information (administration, logistic) and tools (surveys, grades). GitHub (under your own account) for accessing feedback of your labs.","title":"Home"},{"location":"index.html#cs2030s-programming-methodology-ii","text":"","title":"CS2030S Programming Methodology II"},{"location":"index.html#ay-202021-semester-2","text":"This website hosts the lecture notes, lecture slides, and other written guides about CS2030S. You can explore the links on the menu on the left, or search for keywords in the search bar above.","title":"AY 2020/21 Semester 2"},{"location":"index.html#other-critical-web-resources","text":"Piazza for Q&A and discussions LumiNUS for all other information (administration, logistic) and tools (surveys, grades). GitHub (under your own account) for accessing feedback of your labs.","title":"Other Critical Web Resources"},{"location":"00-overview.html","text":"Unit 0. Overview Learning Outcomes This unit provides an overview of the aims of CS2030/S and how the key concepts covered in CS2030/S are related to each other. What is This Module About? CS2030/S is designed for students who have gone through a typical basic programming module module and have learned about problem solving with simple programming constructs such as loops, conditions, and functions. In a typical introductory programming module, such as CS1010 and its variants at NUS, students tend to write small programs (in the order of tens or hundreds of lines of code) to solve a programming homework problem, work alone on their code, and move on to solve the next problem once the homework is done. The first aim of CS2030/S is to change the students' mindset and to make them learn to write software that will continue to evolve as software requirements change, and to write software that will be read and modified by other programmers (including their future selves). The second aim of CS2030/S is to level-up the complexity of programs that the students write, from order of hundreds of lines to thousands of lines. CS2030/S bridges the students between writing toy programs to solve specific problem in CS1010 and writing larger real-world software in their later modules, such as CS2103 Software Engineering. A programming language is the medium in which programmers can express their intention and construct software, and thus is critical to supporting the aims above. With the appropriate features and tools, one can tame the complexity of software, make the code written friendlier to other programmers, and easier to evolve. The third aim of CS2030/S is thus to expand the students' mind on different ways one can construct software and the principles behind some of the programming language constructs. In particular, CS2030/S focuses on objects, types, and functions, as three key constructs towards building programmer-friendly software. It covers both object-oriented and functional paradigms as two different approaches to construct software, with a strong emphasis on type safety. The final aim of CS2030/S is to introduce students to programming language concepts, to bridge them from introductory programming to advanced modules such as programming language design and implementations. Part of CS2030/S introduces students to the design decisions behind some of the constraints and the workings behind the programming language compilation and execution, giving them a glimpse inside the programming system that so far has been mostly treated as a black box in introductory modules. The Choice of Java We decided to use one programming language throughout the module. This decision means that we need to pick a language which is strongly typed with static typing, and supports both object-oriented and functional programming. Considering multiple factors, we decided to choose Java for CS2030/S, for its popularity, syntax familiarity, and smoother transitions to later modules in the NUS computing curriculum. While Java is definitely not the most elegant programming language when expressing programs in functional style, we hope that students can still learn the principles of functional programming and apply it in other programming languages. This choice is a trade-off between having to switch to a different language in the middle of a module. What This Module is not About This is not a module on Java programming. We will not comprehensively cover Java syntax and features, except those relevant to the concepts we teach. In fact, we will avoid and even ban students from using certain Java features (such as var ) for pedagogical purposes. This is not a module on software engineering either. Software engineering is a broad discipline on its own and deserves another module. Rather, this module is about the programming principles and constructs on top of which programmers can design better software. To motivate the importance of these principles and constructs and see how they can be used, we will inevitably cover some of the software engineering design principles, such as the Liskov's Substitution Principle (the L in SOLID), Tell-Don't-Ask, Composition over Inheritance, etc. But we will not comprehensively cover object-oriented design or software design in general (e.g., we will not cover S,O,I,D in SOLID). Finally, CS2030/S is not a module that focuses on computational efficiency. We have CS2040/S for that. In CS2030/S, although reducing computational cost still plays a role, this is not the only cost that matters. CS2030/S is also concerned with the human cost of debugging or maintaining software. In striving for simpler software that is easier to maintain and extend, we may have to sacrifice computational efficiency. Taming Complexity in Software Development An underlying theme of CS2030/S is taming complexity in software development. There are objective metrics with which one can measure the complexity of software, but here, we will loosely define complexity as anything that increases the likelihood of bugs in a program. Let's start by considering a simplified view of what a software program is. One can view a software program as a collection of data variables and instructions on how to modify these variables. A program is generally written to meet a given requirement: given one or more input variables, the program should perform the computation to produce the output variables, in a way that meets the requirement. Often, the program stores information in the intermediate variables while performing the computation. As a student who has gone through an introductory programming module such as CS1010 and its variants, you should be familiar with the view above, and you should have some experience writing program to solve a given computational problem. The program you have written for these introductory modules are small \"toy\" programs mostly -- they consists of only a few hundreds of lines and tens of variables, at most. Software development in the real world, however, is far more complex than what you have experienced. A software program rarely solves a well-defined computational problem only. It often requires multiple components, such as user interface, data storage, and business rules, interacting with each other in an intricate manner to attain a set of functionalities. As the requirement of the software becomes more complex, the number of variables that needs to be kept track of increases; the logic of the computation the programmer needs to maintain the variables becomes more complicated. Further, it is often that the variables are inter-dependent of each other. For instance, updating a variable might require updating another; how a variable should be updated might depend on another variable. As the number of variables increases, so is the number of relationships between the variables that the programer has to keep track of. Failure to correctly maintain the variables and the relationship between them most likely will lead to bugs. Further, real world software rarely remains static. This property, is again different from what you have experienced in your introductory programming module, where once the instructors release a programming homework, they rarely go back and change the requirement. In the real world, software evolves over time -- new features are added, business rules changes, better algorithms are deployed. The code needs to be updated accordingly -- adding new variables and new computation; changing how variables are updated or are dependent on each other. Updating the code of an already-complex software program to keep up with the requirement, if not managed properly, can lead to bugs. Real world software is often the product of teamwork from multiple programmers, where the software development process is unlike what you have experienced in your introductory programming module, where you solve your homework individually. When multiple programmers work together, the interdependency between the states need to be communicated and handled properly and consistently across the programmers. One programmer's modification to the code should not introduce bugs into another programmer's code. Since software evolves over time, the notion of \"multiple programmers\" actually applies even to software developed by a single lone programmer across time. Changing one's code should not introduce new bugs to other parts of the code that is written some time ago. Strategies to Tame Complexity Good Software Development Practices If you are taught properly in your introductory programming modules, you should already be familiar with some of the good programming practices that help to tame the complexity and reduce the chances of bugs. These practices include Comment your code: Commenting your code provides in situ communication between you and other programmers on the team, as well as between you and your future self, on the non-obvious purpose of the states and the relationships between the states. Such comments help to enhance the understanding of what the code is doing and to remind whoever is updating to code to modify appropriately when the requirement changes. Use a coding convention: Adhering to a coding convention helps improves code readability, reducing the cognitive barrier when one programmer reads another programmer's code and allowing the reader to understand the code more easily and thoroughly. CS2030/S will continue to enforce these good programming practices. Functions You should also be taught to always break you code down into functions, each one performs a simple, specific, task. The functions can then be composed to solve larger and more complex tasks. Functions are an important programming structure in taming code complexity, it allows programmers to (i) compartmentalize computation and its effects, reducing the amount of interactions to a few well defined ones (through arguments and return values); (ii) hide the implementation details so that they can be changed later without affecting other parts of the code; (iii) reuse computations and thus write code that is more succinct and easier to understand/change. In CS2030/S, you will not only continue to break your computation into functions, but we will kick it up several notches. A major part of CS2030/S is to introduce you to more programming paradigms and language tools that allow you to compartmentalize computations, hide details, and reduce repetition. The Abstraction Principle The last point above about why it is important to code in small, reusable functions, follows what is called the Abstraction Principle 1 . The principle states that: \"Each significant piece of functionality in a program should be implemented in just one place in the source code. Where similar functions are carried out by distinct pieces of code, it is generally beneficial to combine them into one by abstracting out the varying parts.\" This principle is something that we will visit over and over again in CS2030/S, applying it to different varying parts of a program. In the case of functions, the \"varying parts\" are the values on which we wish to perform the computation on. We will also apply this principle to (i) types, abstracting them out as parameterized types or subtypes, and (ii) to sub-computation, abstracting them out as first-class functions. These concepts: generics, subtypes, first-class functions, underlies most of the content of CS2030/S. Erecting an Abstraction Barrier Another important strategy for taming complexity is the abstraction barrier . Let's separate the role of a programmer into two, in the context of writing functions: the implementer , who implements the function, and a client , who calls the function. The implementer should compartmentalize the internal variables and the implementation of the function, hiding them behind the abstraction barrier, exposing the parameters and return values as the only communication gateways across the barrier. The abstraction barrier is something that we will refer to repeatedly in CS2030/S as well. We will see how we maintain this barrier not only in the context of functions, but also variables and computations on these variables together, by encapsulating them as objects , and hiding details from the client through access modifiers . These ideas form two of the core principles of object-oriented programming : encapsulation and abstraction . Code for Change The abstraction barrier, if erected and maintained properly, reduces code complexity. It, however, also reduces the flexibility as the software evolves. If the client wishes to modify the computation protected by the abstraction barrier, it will need the help of the implementer. In CS2030/S, we will see two ways we can modify the computation behind the abstraction barrier, without changing the code behind the barrier . First, we will introduce the concept of inheritance and polymorphism , the other two core principles of object-oriented programming. These object-oriented mechanisms allow programmers to easily extend or modify the behavior of existing code. Second, we will introduce closure , an abstraction to a computation and its environment, that we can pass into the functions behind the abstraction barrier to perform a computation. The second idea, if carried to the extreme in terms of flexibility, leads to the concept of monad in functional programming paradigm. A monad is a computational structure that allows objects to be composed and manipulated in a succinct and powerful way. Types Allowing a programmer to change the behavior of the existing code without changing the code could lead to more bugs, if not managed properly. To prevent this, both the programming language system, and the programmers, have to adhere to certain rules when extending or modifying the behavior of the existing code. Java and many other typed languages have type systems -- a set of rules that governs how variables, expressions, and functions interact with each other. You will learn about subtyping and the Liskov Substitution Principle, two notions that are important to constraining how inheritance and polymorphism should be used to avoid bugs. A type system is also an important tools to reduce the complexity of software development. By constraining the interactions among the variables, expressions, functions, it reduces the possible interdependence between these programming constructs. Furthermore, any attempt by programmers to break the constraint can be caught automatically. By utilizing the type system properly, we can detect potential bugs before it manifests itself. A reason CS2030/S chooses to use Java is due to its type system. CS2030/S will introduce the concept of types, subtypes, compile-time vs. run-time types, variants of types, parameterized types, and type inferences, in the context of Java. We will see how we can define our own types (using classes and interfaces ) and define relationships between them. We will see how we can define parameterized types and generic functions that takes in types as parameters. These concepts are applicable to many other programming languages. Eliminating Side Effects We have discussed how functions can compartmentalize computations and isolate its complexity to within its body. For this approach to be effective, the function must not have any side effect -- such as updating a variable that is not within the function. Such functions, called pure functions , is one of the key principles of the functional programming paradigm, and is something that we will explore to kick off the section on functional paradigm in CS2030/S. A related idea in object-oriented programming we will cover in CS2030/S is immutability -- once we create an object, the object cannot be changed. In order to update an object, we need to create a new one. With immutability and pure functions, we can guarantee that the same function invoked on the same objects will always return the same value. This certainty can help in understanding and reasoning about the code behavior. This principle is formulated by Benjamin C. Pierce in his book \"Types and Programming Languages.\" \u21a9","title":"0. Overview"},{"location":"00-overview.html#unit-0-overview","text":"","title":"Unit 0. Overview"},{"location":"00-overview.html#learning-outcomes","text":"This unit provides an overview of the aims of CS2030/S and how the key concepts covered in CS2030/S are related to each other.","title":"Learning Outcomes"},{"location":"00-overview.html#what-is-this-module-about","text":"CS2030/S is designed for students who have gone through a typical basic programming module module and have learned about problem solving with simple programming constructs such as loops, conditions, and functions. In a typical introductory programming module, such as CS1010 and its variants at NUS, students tend to write small programs (in the order of tens or hundreds of lines of code) to solve a programming homework problem, work alone on their code, and move on to solve the next problem once the homework is done. The first aim of CS2030/S is to change the students' mindset and to make them learn to write software that will continue to evolve as software requirements change, and to write software that will be read and modified by other programmers (including their future selves). The second aim of CS2030/S is to level-up the complexity of programs that the students write, from order of hundreds of lines to thousands of lines. CS2030/S bridges the students between writing toy programs to solve specific problem in CS1010 and writing larger real-world software in their later modules, such as CS2103 Software Engineering. A programming language is the medium in which programmers can express their intention and construct software, and thus is critical to supporting the aims above. With the appropriate features and tools, one can tame the complexity of software, make the code written friendlier to other programmers, and easier to evolve. The third aim of CS2030/S is thus to expand the students' mind on different ways one can construct software and the principles behind some of the programming language constructs. In particular, CS2030/S focuses on objects, types, and functions, as three key constructs towards building programmer-friendly software. It covers both object-oriented and functional paradigms as two different approaches to construct software, with a strong emphasis on type safety. The final aim of CS2030/S is to introduce students to programming language concepts, to bridge them from introductory programming to advanced modules such as programming language design and implementations. Part of CS2030/S introduces students to the design decisions behind some of the constraints and the workings behind the programming language compilation and execution, giving them a glimpse inside the programming system that so far has been mostly treated as a black box in introductory modules.","title":"What is This Module About?"},{"location":"00-overview.html#the-choice-of-java","text":"We decided to use one programming language throughout the module. This decision means that we need to pick a language which is strongly typed with static typing, and supports both object-oriented and functional programming. Considering multiple factors, we decided to choose Java for CS2030/S, for its popularity, syntax familiarity, and smoother transitions to later modules in the NUS computing curriculum. While Java is definitely not the most elegant programming language when expressing programs in functional style, we hope that students can still learn the principles of functional programming and apply it in other programming languages. This choice is a trade-off between having to switch to a different language in the middle of a module.","title":"The Choice of Java"},{"location":"00-overview.html#what-this-module-is-not-about","text":"This is not a module on Java programming. We will not comprehensively cover Java syntax and features, except those relevant to the concepts we teach. In fact, we will avoid and even ban students from using certain Java features (such as var ) for pedagogical purposes. This is not a module on software engineering either. Software engineering is a broad discipline on its own and deserves another module. Rather, this module is about the programming principles and constructs on top of which programmers can design better software. To motivate the importance of these principles and constructs and see how they can be used, we will inevitably cover some of the software engineering design principles, such as the Liskov's Substitution Principle (the L in SOLID), Tell-Don't-Ask, Composition over Inheritance, etc. But we will not comprehensively cover object-oriented design or software design in general (e.g., we will not cover S,O,I,D in SOLID). Finally, CS2030/S is not a module that focuses on computational efficiency. We have CS2040/S for that. In CS2030/S, although reducing computational cost still plays a role, this is not the only cost that matters. CS2030/S is also concerned with the human cost of debugging or maintaining software. In striving for simpler software that is easier to maintain and extend, we may have to sacrifice computational efficiency.","title":"What This Module is not About"},{"location":"00-overview.html#taming-complexity-in-software-development","text":"An underlying theme of CS2030/S is taming complexity in software development. There are objective metrics with which one can measure the complexity of software, but here, we will loosely define complexity as anything that increases the likelihood of bugs in a program. Let's start by considering a simplified view of what a software program is. One can view a software program as a collection of data variables and instructions on how to modify these variables. A program is generally written to meet a given requirement: given one or more input variables, the program should perform the computation to produce the output variables, in a way that meets the requirement. Often, the program stores information in the intermediate variables while performing the computation. As a student who has gone through an introductory programming module such as CS1010 and its variants, you should be familiar with the view above, and you should have some experience writing program to solve a given computational problem. The program you have written for these introductory modules are small \"toy\" programs mostly -- they consists of only a few hundreds of lines and tens of variables, at most. Software development in the real world, however, is far more complex than what you have experienced. A software program rarely solves a well-defined computational problem only. It often requires multiple components, such as user interface, data storage, and business rules, interacting with each other in an intricate manner to attain a set of functionalities. As the requirement of the software becomes more complex, the number of variables that needs to be kept track of increases; the logic of the computation the programmer needs to maintain the variables becomes more complicated. Further, it is often that the variables are inter-dependent of each other. For instance, updating a variable might require updating another; how a variable should be updated might depend on another variable. As the number of variables increases, so is the number of relationships between the variables that the programer has to keep track of. Failure to correctly maintain the variables and the relationship between them most likely will lead to bugs. Further, real world software rarely remains static. This property, is again different from what you have experienced in your introductory programming module, where once the instructors release a programming homework, they rarely go back and change the requirement. In the real world, software evolves over time -- new features are added, business rules changes, better algorithms are deployed. The code needs to be updated accordingly -- adding new variables and new computation; changing how variables are updated or are dependent on each other. Updating the code of an already-complex software program to keep up with the requirement, if not managed properly, can lead to bugs. Real world software is often the product of teamwork from multiple programmers, where the software development process is unlike what you have experienced in your introductory programming module, where you solve your homework individually. When multiple programmers work together, the interdependency between the states need to be communicated and handled properly and consistently across the programmers. One programmer's modification to the code should not introduce bugs into another programmer's code. Since software evolves over time, the notion of \"multiple programmers\" actually applies even to software developed by a single lone programmer across time. Changing one's code should not introduce new bugs to other parts of the code that is written some time ago.","title":"Taming Complexity in Software Development"},{"location":"00-overview.html#strategies-to-tame-complexity","text":"","title":"Strategies to Tame Complexity"},{"location":"00-overview.html#good-software-development-practices","text":"If you are taught properly in your introductory programming modules, you should already be familiar with some of the good programming practices that help to tame the complexity and reduce the chances of bugs. These practices include Comment your code: Commenting your code provides in situ communication between you and other programmers on the team, as well as between you and your future self, on the non-obvious purpose of the states and the relationships between the states. Such comments help to enhance the understanding of what the code is doing and to remind whoever is updating to code to modify appropriately when the requirement changes. Use a coding convention: Adhering to a coding convention helps improves code readability, reducing the cognitive barrier when one programmer reads another programmer's code and allowing the reader to understand the code more easily and thoroughly. CS2030/S will continue to enforce these good programming practices.","title":"Good Software Development Practices"},{"location":"00-overview.html#functions","text":"You should also be taught to always break you code down into functions, each one performs a simple, specific, task. The functions can then be composed to solve larger and more complex tasks. Functions are an important programming structure in taming code complexity, it allows programmers to (i) compartmentalize computation and its effects, reducing the amount of interactions to a few well defined ones (through arguments and return values); (ii) hide the implementation details so that they can be changed later without affecting other parts of the code; (iii) reuse computations and thus write code that is more succinct and easier to understand/change. In CS2030/S, you will not only continue to break your computation into functions, but we will kick it up several notches. A major part of CS2030/S is to introduce you to more programming paradigms and language tools that allow you to compartmentalize computations, hide details, and reduce repetition.","title":"Functions"},{"location":"00-overview.html#the-abstraction-principle","text":"The last point above about why it is important to code in small, reusable functions, follows what is called the Abstraction Principle 1 . The principle states that: \"Each significant piece of functionality in a program should be implemented in just one place in the source code. Where similar functions are carried out by distinct pieces of code, it is generally beneficial to combine them into one by abstracting out the varying parts.\" This principle is something that we will visit over and over again in CS2030/S, applying it to different varying parts of a program. In the case of functions, the \"varying parts\" are the values on which we wish to perform the computation on. We will also apply this principle to (i) types, abstracting them out as parameterized types or subtypes, and (ii) to sub-computation, abstracting them out as first-class functions. These concepts: generics, subtypes, first-class functions, underlies most of the content of CS2030/S.","title":"The Abstraction Principle"},{"location":"00-overview.html#erecting-an-abstraction-barrier","text":"Another important strategy for taming complexity is the abstraction barrier . Let's separate the role of a programmer into two, in the context of writing functions: the implementer , who implements the function, and a client , who calls the function. The implementer should compartmentalize the internal variables and the implementation of the function, hiding them behind the abstraction barrier, exposing the parameters and return values as the only communication gateways across the barrier. The abstraction barrier is something that we will refer to repeatedly in CS2030/S as well. We will see how we maintain this barrier not only in the context of functions, but also variables and computations on these variables together, by encapsulating them as objects , and hiding details from the client through access modifiers . These ideas form two of the core principles of object-oriented programming : encapsulation and abstraction .","title":"Erecting an Abstraction Barrier"},{"location":"00-overview.html#code-for-change","text":"The abstraction barrier, if erected and maintained properly, reduces code complexity. It, however, also reduces the flexibility as the software evolves. If the client wishes to modify the computation protected by the abstraction barrier, it will need the help of the implementer. In CS2030/S, we will see two ways we can modify the computation behind the abstraction barrier, without changing the code behind the barrier . First, we will introduce the concept of inheritance and polymorphism , the other two core principles of object-oriented programming. These object-oriented mechanisms allow programmers to easily extend or modify the behavior of existing code. Second, we will introduce closure , an abstraction to a computation and its environment, that we can pass into the functions behind the abstraction barrier to perform a computation. The second idea, if carried to the extreme in terms of flexibility, leads to the concept of monad in functional programming paradigm. A monad is a computational structure that allows objects to be composed and manipulated in a succinct and powerful way.","title":"Code for Change"},{"location":"00-overview.html#types","text":"Allowing a programmer to change the behavior of the existing code without changing the code could lead to more bugs, if not managed properly. To prevent this, both the programming language system, and the programmers, have to adhere to certain rules when extending or modifying the behavior of the existing code. Java and many other typed languages have type systems -- a set of rules that governs how variables, expressions, and functions interact with each other. You will learn about subtyping and the Liskov Substitution Principle, two notions that are important to constraining how inheritance and polymorphism should be used to avoid bugs. A type system is also an important tools to reduce the complexity of software development. By constraining the interactions among the variables, expressions, functions, it reduces the possible interdependence between these programming constructs. Furthermore, any attempt by programmers to break the constraint can be caught automatically. By utilizing the type system properly, we can detect potential bugs before it manifests itself. A reason CS2030/S chooses to use Java is due to its type system. CS2030/S will introduce the concept of types, subtypes, compile-time vs. run-time types, variants of types, parameterized types, and type inferences, in the context of Java. We will see how we can define our own types (using classes and interfaces ) and define relationships between them. We will see how we can define parameterized types and generic functions that takes in types as parameters. These concepts are applicable to many other programming languages.","title":"Types"},{"location":"00-overview.html#eliminating-side-effects","text":"We have discussed how functions can compartmentalize computations and isolate its complexity to within its body. For this approach to be effective, the function must not have any side effect -- such as updating a variable that is not within the function. Such functions, called pure functions , is one of the key principles of the functional programming paradigm, and is something that we will explore to kick off the section on functional paradigm in CS2030/S. A related idea in object-oriented programming we will cover in CS2030/S is immutability -- once we create an object, the object cannot be changed. In order to update an object, we need to create a new one. With immutability and pure functions, we can guarantee that the same function invoked on the same objects will always return the same value. This certainty can help in understanding and reasoning about the code behavior. This principle is formulated by Benjamin C. Pierce in his book \"Types and Programming Languages.\" \u21a9","title":"Eliminating Side Effects"},{"location":"01-compiler.html","text":"Unit 1: Program and Compiler After reading this unit, students should: recap some fundamental programming concepts, including the concept of a program, a programming language, a compiler, and an interpreter be aware of two modes of running a Java program (compiled vs. interpreted) be aware that compile-time errors are better than run-time errors, but the compiler cannot always detect errors during compile time Software Program A software program is a collection of data variables and instructions on how to modify these variables. To dictate these instructions to the computer, programmers usually write down the instructions using a programming language, expressing their instructions in code that are made up of keywords, symbols, and names. A programming language is a formal language that helps programmers specify precisely what the instructions are at a higher level of abstraction (i.e., at a higher conceptual level) so that a programmer only needs to write a few lines of code to give complex instructions to the computer. Compiled vs. Interpreted Programs The processing unit of a computer can only accept and understand instructions written in machine code. A program, written in a higher-level programming language, therefore needs to be translated into machine code before execution. There are different approaches to how such translations can be done. The first approach uses a compiler -- a software tool that reads in the entire program written in a higher-level programming language and translates it into machine code. The machine code is then saved into an executable file, which can be executed later. clang , a C/C++ compiler, is an example. The second approach uses an interpreter -- software that reads in the program one statement at a time interprets what the statement means, and executes its directly. This is how Python and Javascript programs are executed. Modern programming systems for executing programs are, however, more sophisticated. V8, for instance, is an open-source engine that executes Javascript, and it contains both an interpreter that first interprets a Javascript into bytecode (an intermediate, low-level representation). A just-in-time compiler then reads in the bytecode and generates machine code dynamically at runtime with optimized performance. Java programs, on the other hand, can be executed in two ways. The Java program can first be compiled into bytecode. During execution, the bytecode is interpreted and compiled on-the-fly by the Java Virtual Machine (JVM) into machine code. The Java program can also be interpreted by the Java interpreter. Since CS2030/S uses Java, let's look at the two approaches in more detail (without worrying about how to write a single line of Java first). Compiling and Running Java Programs Suppose we have a Java program called Hello.java . To compile the program, we type 1 1 $ javac Hello.java into the command line. javac is the Java compiler. This step will either lead to the bytecode called Hello.class being created or spew out some errors. Assuming that there is no error, we can now run 1 $ java Hello to invoke the JVM java and execute the bytecode contains in Hello.class . Beginners tend to confuse between javac and java , and whether to add the extension .java or .class when compiling and executing a Java program. Do take note and refer back here if needed 2 . Interpreting a Java program Java (version 8 or later) comes with an interpreter called jshell that can read in Java statements, evaluate them, and print the results 3 . jshell is useful for learning and experimenting about Java. To run jshell in interactive mode, we type 1 $ jshell on the command line, which causes an interactive prompt to appear: 1 2 3 4 5 $ jshell | Welcome to JShell -- Version 11.0.2 | For an introduction type: /help intro jshell> We can now type in Java code on jshell> . Alternatively, we can also include all the Java statements that we want jshell to run in a file and pass it into jshell 1 $ jshell Hello.jsh While jshell is a convenient way to test things out and play with new Java concepts as we learn, do keep in mind that jshell combined both compilation and run-time into a single step. The error spewed out by jshell could be either compile-time error or run-time error, and this could be confusing to beginners who try to distinguish between the two phases of program execution. Compiler The compiler does more than just translating source code into machine code or bytecode. The compiler also needs to parse the source code written and check if it follows the precise specification of the programming language (called grammar ) used, and produces a syntax error if the grammar is violated. It therefore can detect any syntax error before the program is run. It is much better for a programmer to detect any error in its code during compilation -- since this is the phase when the program is still being developed and under the control of the programmer. Runtime error, on the other hand, might occur when the customers are running the program, and so are much less desirable. As such, we try to detect errors as much as possible during compilation. The compiler is a powerful friend for any programmer if used properly. The power of the compiler, however, is limited. A compiler can only read and analyze the source code without actually running it. Without running the program, the compiler cannot always tell if a particular statement in the source code will ever be executed; it cannot always tell what values a variable will take. To deal with this, the compiler can either be conservative , and report an error as long as there is a possibility that a particular statement is incorrect; or, the compiler can be more permissive , reporting an error only if there is no possiblity that a particular statement is correct. If there is a possibility that a particular statement is correct, it does not throw an error, but rely on the programmer to do the right thing. We will further contrast these two behaviors later in this module. The $ represents the command prompt in a shell and you do not need to type this. \u21a9 To add to the confusion, Java 11 introduces a shortcut where we can run java Hello.java directly. This command causes Hello.java to be compiled and executed in a single step. We won't do this in CS2030/S (i) to avoid confusion and (ii) to show you the steps explicitly. \u21a9 Such a program is called REPL (Read-Evaluate-Print in a Loop) for short. \u21a9","title":"1. Program and Compiler"},{"location":"01-compiler.html#unit-1-program-and-compiler","text":"After reading this unit, students should: recap some fundamental programming concepts, including the concept of a program, a programming language, a compiler, and an interpreter be aware of two modes of running a Java program (compiled vs. interpreted) be aware that compile-time errors are better than run-time errors, but the compiler cannot always detect errors during compile time","title":"Unit 1: Program and Compiler"},{"location":"01-compiler.html#software-program","text":"A software program is a collection of data variables and instructions on how to modify these variables. To dictate these instructions to the computer, programmers usually write down the instructions using a programming language, expressing their instructions in code that are made up of keywords, symbols, and names. A programming language is a formal language that helps programmers specify precisely what the instructions are at a higher level of abstraction (i.e., at a higher conceptual level) so that a programmer only needs to write a few lines of code to give complex instructions to the computer.","title":"Software Program"},{"location":"01-compiler.html#compiled-vs-interpreted-programs","text":"The processing unit of a computer can only accept and understand instructions written in machine code. A program, written in a higher-level programming language, therefore needs to be translated into machine code before execution. There are different approaches to how such translations can be done. The first approach uses a compiler -- a software tool that reads in the entire program written in a higher-level programming language and translates it into machine code. The machine code is then saved into an executable file, which can be executed later. clang , a C/C++ compiler, is an example. The second approach uses an interpreter -- software that reads in the program one statement at a time interprets what the statement means, and executes its directly. This is how Python and Javascript programs are executed. Modern programming systems for executing programs are, however, more sophisticated. V8, for instance, is an open-source engine that executes Javascript, and it contains both an interpreter that first interprets a Javascript into bytecode (an intermediate, low-level representation). A just-in-time compiler then reads in the bytecode and generates machine code dynamically at runtime with optimized performance. Java programs, on the other hand, can be executed in two ways. The Java program can first be compiled into bytecode. During execution, the bytecode is interpreted and compiled on-the-fly by the Java Virtual Machine (JVM) into machine code. The Java program can also be interpreted by the Java interpreter. Since CS2030/S uses Java, let's look at the two approaches in more detail (without worrying about how to write a single line of Java first).","title":"Compiled vs. Interpreted Programs"},{"location":"01-compiler.html#compiling-and-running-java-programs","text":"Suppose we have a Java program called Hello.java . To compile the program, we type 1 1 $ javac Hello.java into the command line. javac is the Java compiler. This step will either lead to the bytecode called Hello.class being created or spew out some errors. Assuming that there is no error, we can now run 1 $ java Hello to invoke the JVM java and execute the bytecode contains in Hello.class . Beginners tend to confuse between javac and java , and whether to add the extension .java or .class when compiling and executing a Java program. Do take note and refer back here if needed 2 .","title":"Compiling and Running Java Programs"},{"location":"01-compiler.html#interpreting-a-java-program","text":"Java (version 8 or later) comes with an interpreter called jshell that can read in Java statements, evaluate them, and print the results 3 . jshell is useful for learning and experimenting about Java. To run jshell in interactive mode, we type 1 $ jshell on the command line, which causes an interactive prompt to appear: 1 2 3 4 5 $ jshell | Welcome to JShell -- Version 11.0.2 | For an introduction type: /help intro jshell> We can now type in Java code on jshell> . Alternatively, we can also include all the Java statements that we want jshell to run in a file and pass it into jshell 1 $ jshell Hello.jsh While jshell is a convenient way to test things out and play with new Java concepts as we learn, do keep in mind that jshell combined both compilation and run-time into a single step. The error spewed out by jshell could be either compile-time error or run-time error, and this could be confusing to beginners who try to distinguish between the two phases of program execution.","title":"Interpreting a Java program"},{"location":"01-compiler.html#compiler","text":"The compiler does more than just translating source code into machine code or bytecode. The compiler also needs to parse the source code written and check if it follows the precise specification of the programming language (called grammar ) used, and produces a syntax error if the grammar is violated. It therefore can detect any syntax error before the program is run. It is much better for a programmer to detect any error in its code during compilation -- since this is the phase when the program is still being developed and under the control of the programmer. Runtime error, on the other hand, might occur when the customers are running the program, and so are much less desirable. As such, we try to detect errors as much as possible during compilation. The compiler is a powerful friend for any programmer if used properly. The power of the compiler, however, is limited. A compiler can only read and analyze the source code without actually running it. Without running the program, the compiler cannot always tell if a particular statement in the source code will ever be executed; it cannot always tell what values a variable will take. To deal with this, the compiler can either be conservative , and report an error as long as there is a possibility that a particular statement is incorrect; or, the compiler can be more permissive , reporting an error only if there is no possiblity that a particular statement is correct. If there is a possibility that a particular statement is correct, it does not throw an error, but rely on the programmer to do the right thing. We will further contrast these two behaviors later in this module. The $ represents the command prompt in a shell and you do not need to type this. \u21a9 To add to the confusion, Java 11 introduces a shortcut where we can run java Hello.java directly. This command causes Hello.java to be compiled and executed in a single step. We won't do this in CS2030/S (i) to avoid confusion and (ii) to show you the steps explicitly. \u21a9 Such a program is called REPL (Read-Evaluate-Print in a Loop) for short. \u21a9","title":"Compiler"},{"location":"02-type.html","text":"Unit 2: Variable and Type After this unit, students should be able to: appreciate the concept of variables as an abstraction understand the concept of types and subtypes contrast between statically typed language vs. dynamically typed language contrast between strongly typed language vs. weakly typed language be familiar with Java variables and primitive types understand widening type conversion in the context of variable assignments and how subtyping dictates whether the type conversion is allowed. Data Abstraction: Variable One of the important abstractions that are provided by a programming language is the variable . Data are stored in some location in computer memory. But we should not be referring to the memory location all the time. First, referring to something like 0xFA49130E is not user-friendly; Second, the location may change. A variable is an abstraction that allows us to give a user-friendly name to a piece of data in memory. We use the variable name whenever we want to access the value in that location, and pointer to the variable or reference to the variable whenever we want to refer to the address of the location. Type As programs get more complex, the number of variables that the programmer needs to keep track of increases. These variables might be an abstraction over different types of data: some variables might refer to a number, some to a string, some to a list of numbers, etc. Not all operations are meaningful over all types of data. To help mitigate the complexity, we can assign a type to a variable. The type communicates to the readers what data type the variable is an abstraction over, and to the compiler/interpreter what operations are valid on this variable and how the operation behaves. In lower-level programming languages like C, the type also informs the compiler how the bit representing the variable should be interpreted. As an example of how types can affect how an operation behaves, let's consider Python. Suppose we have two variables x and y , storing the values 4 and 5 respectively and we run print x + y . If x and y are both strings, you would get 45 ; if x and y are integers, you would get 9 ; if 4 is an integer and 5 is a string, you would get an error. In the last instance above, you see that assigning a type to each variable helps to keep the program meaningful, as the operation + is not defined over an integer and a string in Python. Java and Javascript, however, would happily convert 4 into a string for you, and return 45 . Dynamic vs. Static Type Python and Javascript are examples of dynamically typed programming languages. The same variable can hold values of different types, and checking if the right type is used is done during the execution of the program. Note that, the type is associated with the values , and the type of the variable changes depending on the value it holds. For example, we can do the following: 1 2 i = 4 // i is an integer i = \"5\" // ok, i is now a string Java, on the other hand, is a statically typed language. We need to declare every variable we use in the program and specify its type. A variable can only hold values of the same type as the type of the variable, so we can't assign, for instance, a string to a variable of type int . Once a variable is assigned a type, its type cannot be changed. 1 2 3 int i ; // declare a variable i = 4 ; // ok i = \"5\" ; // error, cannot assign a string to an `int` The type that a variable is assigned with when we declare the variable is also known as the compile-time type . During the compilation, this is the only type that the compiler is aware of. The compiler will check if the compile-time type matches when it parses the variables, expressions, values, and function calls, and throw an error if there is a type mismatch. This type-checking step helps to catch errors in the code early. Strong Typing vs. Weak Typing A type system of a programming language is a set of rules that govern how the types can interact with each other. A programming language can be strongly typed or weakly typed. There are no formal definitions of \"strong\" vs. \"weak\" typing of a programming language, and there is a spectrum of \"strength\" between the typing discipline of a language. Generally, a strongly typed programming language enforces strict rules in its type system, to ensure type safety , i.e., to catch type errors during compile time rather than leaving it to runtime. On the other hand, a weakly typed (or loosely typed ) programming language is more permissive in terms of typing checking. C is an example of a static, weakly typed language. In C, the following is possible: 1 2 3 int i ; // declare a variable i = 4 ; // ok i = ( int ) \"5\" ; // you want to treat a string as an int? ok, as you wish! The last line forces the C compiler to treat the string (to be more precise, the address of the string) as an integer, through typecasting. In contrast, if we try the following in Java: 1 2 3 int i ; // declare a variable i = 4 ; // ok i = ( int ) \"5\" ; // error we will get the following compile-time error message: 1 | incompatible types: java.lang.String cannot be converted to int because the compiler enforces a stricter rule and allows typecasting only if it makes sense. Type Checking with A Compiler In addition to checking for syntax errors, the compiler can check for type compilability according to the compile-time type, to catch possible errors as early as possible. Such type checking is made possible with static typing. Consider the following Python program: 1 2 3 4 5 i = 0 while ( i < 10 ): # do something that takes time i = i + 1 print ( \"i is \" + i ) The type mismatch error on Line 5 is only caught when Line 5 is executed. Since the type of the variable i can change during run time, Python (and generally, dynamically typed languages) can not tell if Line 5 will lead to an error until it is evaluated at run-time. In contrast, statically typed language like Java can detect type mismatch during compile time since the compile-time type of a variable is fixed. Primitive Types in Java We now switch our focus to Java, particularly to the types supported. There are two categories of types in Java, the primitive types and the reference types . We will first look at primitive types in this unit. Primitive types are types that holds numeric values (integers, floating-point numbers) as well as boolean values ( true and false ). For storing integral values, Java provides four types, byte , short , int , and long , for storing 8-bit, 16-bit, 32-bit, 64-bit signed integers respectively. The type char stores 16-bit unsigned integers representing UTF-16 Unicode characters. For storing floating-point values, Java provides two types, float and double , for 16-bit and 32-bit floating-point numbers. Unlike reference types, which we will see later, primitive type variables never share their value with each other, i.e., if we have: 1 2 3 int i = 1000 ; int j = i ; i = i + 1 ; i and j each store a copy of the value 1000 after Line 2. Changing i on Line 3 does not change the content of j . Subtypes An important concept that we will visit repeatedly in CS2030/S is the concept of subtypes. Let \\(S\\) and \\(T\\) be two types. We say that \\(T\\) is a subtype of \\(S\\) if a piece of code written for variables of type \\(S\\) can also safely be used on variables of type \\(T\\) . We use the notation \\(T <: S\\) or \\(S :> T\\) to denote that \\(T\\) is subtype of \\(S\\) . The subtype relationship is transitive, i.e., if \\(S <: T\\) and \\(T <: U\\) , then \\(S <: U\\) . It is also reflexive, for any type \\(S\\) , \\(S <: S\\) . We also use the term supertype to denote the reversed relationship: if \\(T\\) is a subtype of \\(S\\) , then \\(S\\) is a supertype of \\(T\\) . Subtyping Between Java Primitive Types Consider the range of values that the primitive types can take, Java defines the following subtyping relationship: byte <: short <: int <: long <: float <: double char <: int Valid subtype relationship is part of what the Java compiler checks for when it compiles. Consider the following example: 1 2 3 4 double d = 5.0 ; int i = 5 ; d = i ; i = d ; // error Line 4 above would lead to an error: 1 | incompatible types: possible lossy conversion from double to int but Line 3 is OK. This example shows how subtyping applies to type checking. Java allows a variable of type \\(T\\) to hold a value from a variable of type \\(S\\) only if \\(S <: T\\) . This step is called widening type conversion . Such conversion can happen during assignment or parameter passing. Additional Readings Java Tutorial: Primitive Data Types and other Language Basics","title":"2. Variable and Type"},{"location":"02-type.html#unit-2-variable-and-type","text":"After this unit, students should be able to: appreciate the concept of variables as an abstraction understand the concept of types and subtypes contrast between statically typed language vs. dynamically typed language contrast between strongly typed language vs. weakly typed language be familiar with Java variables and primitive types understand widening type conversion in the context of variable assignments and how subtyping dictates whether the type conversion is allowed.","title":"Unit 2: Variable and Type"},{"location":"02-type.html#data-abstraction-variable","text":"One of the important abstractions that are provided by a programming language is the variable . Data are stored in some location in computer memory. But we should not be referring to the memory location all the time. First, referring to something like 0xFA49130E is not user-friendly; Second, the location may change. A variable is an abstraction that allows us to give a user-friendly name to a piece of data in memory. We use the variable name whenever we want to access the value in that location, and pointer to the variable or reference to the variable whenever we want to refer to the address of the location.","title":"Data Abstraction: Variable"},{"location":"02-type.html#type","text":"As programs get more complex, the number of variables that the programmer needs to keep track of increases. These variables might be an abstraction over different types of data: some variables might refer to a number, some to a string, some to a list of numbers, etc. Not all operations are meaningful over all types of data. To help mitigate the complexity, we can assign a type to a variable. The type communicates to the readers what data type the variable is an abstraction over, and to the compiler/interpreter what operations are valid on this variable and how the operation behaves. In lower-level programming languages like C, the type also informs the compiler how the bit representing the variable should be interpreted. As an example of how types can affect how an operation behaves, let's consider Python. Suppose we have two variables x and y , storing the values 4 and 5 respectively and we run print x + y . If x and y are both strings, you would get 45 ; if x and y are integers, you would get 9 ; if 4 is an integer and 5 is a string, you would get an error. In the last instance above, you see that assigning a type to each variable helps to keep the program meaningful, as the operation + is not defined over an integer and a string in Python. Java and Javascript, however, would happily convert 4 into a string for you, and return 45 .","title":"Type"},{"location":"02-type.html#dynamic-vs-static-type","text":"Python and Javascript are examples of dynamically typed programming languages. The same variable can hold values of different types, and checking if the right type is used is done during the execution of the program. Note that, the type is associated with the values , and the type of the variable changes depending on the value it holds. For example, we can do the following: 1 2 i = 4 // i is an integer i = \"5\" // ok, i is now a string Java, on the other hand, is a statically typed language. We need to declare every variable we use in the program and specify its type. A variable can only hold values of the same type as the type of the variable, so we can't assign, for instance, a string to a variable of type int . Once a variable is assigned a type, its type cannot be changed. 1 2 3 int i ; // declare a variable i = 4 ; // ok i = \"5\" ; // error, cannot assign a string to an `int` The type that a variable is assigned with when we declare the variable is also known as the compile-time type . During the compilation, this is the only type that the compiler is aware of. The compiler will check if the compile-time type matches when it parses the variables, expressions, values, and function calls, and throw an error if there is a type mismatch. This type-checking step helps to catch errors in the code early.","title":"Dynamic vs. Static Type"},{"location":"02-type.html#strong-typing-vs-weak-typing","text":"A type system of a programming language is a set of rules that govern how the types can interact with each other. A programming language can be strongly typed or weakly typed. There are no formal definitions of \"strong\" vs. \"weak\" typing of a programming language, and there is a spectrum of \"strength\" between the typing discipline of a language. Generally, a strongly typed programming language enforces strict rules in its type system, to ensure type safety , i.e., to catch type errors during compile time rather than leaving it to runtime. On the other hand, a weakly typed (or loosely typed ) programming language is more permissive in terms of typing checking. C is an example of a static, weakly typed language. In C, the following is possible: 1 2 3 int i ; // declare a variable i = 4 ; // ok i = ( int ) \"5\" ; // you want to treat a string as an int? ok, as you wish! The last line forces the C compiler to treat the string (to be more precise, the address of the string) as an integer, through typecasting. In contrast, if we try the following in Java: 1 2 3 int i ; // declare a variable i = 4 ; // ok i = ( int ) \"5\" ; // error we will get the following compile-time error message: 1 | incompatible types: java.lang.String cannot be converted to int because the compiler enforces a stricter rule and allows typecasting only if it makes sense.","title":"Strong Typing vs. Weak Typing"},{"location":"02-type.html#type-checking-with-a-compiler","text":"In addition to checking for syntax errors, the compiler can check for type compilability according to the compile-time type, to catch possible errors as early as possible. Such type checking is made possible with static typing. Consider the following Python program: 1 2 3 4 5 i = 0 while ( i < 10 ): # do something that takes time i = i + 1 print ( \"i is \" + i ) The type mismatch error on Line 5 is only caught when Line 5 is executed. Since the type of the variable i can change during run time, Python (and generally, dynamically typed languages) can not tell if Line 5 will lead to an error until it is evaluated at run-time. In contrast, statically typed language like Java can detect type mismatch during compile time since the compile-time type of a variable is fixed.","title":"Type Checking with A Compiler"},{"location":"02-type.html#primitive-types-in-java","text":"We now switch our focus to Java, particularly to the types supported. There are two categories of types in Java, the primitive types and the reference types . We will first look at primitive types in this unit. Primitive types are types that holds numeric values (integers, floating-point numbers) as well as boolean values ( true and false ). For storing integral values, Java provides four types, byte , short , int , and long , for storing 8-bit, 16-bit, 32-bit, 64-bit signed integers respectively. The type char stores 16-bit unsigned integers representing UTF-16 Unicode characters. For storing floating-point values, Java provides two types, float and double , for 16-bit and 32-bit floating-point numbers. Unlike reference types, which we will see later, primitive type variables never share their value with each other, i.e., if we have: 1 2 3 int i = 1000 ; int j = i ; i = i + 1 ; i and j each store a copy of the value 1000 after Line 2. Changing i on Line 3 does not change the content of j .","title":"Primitive Types in Java"},{"location":"02-type.html#subtypes","text":"An important concept that we will visit repeatedly in CS2030/S is the concept of subtypes. Let \\(S\\) and \\(T\\) be two types. We say that \\(T\\) is a subtype of \\(S\\) if a piece of code written for variables of type \\(S\\) can also safely be used on variables of type \\(T\\) . We use the notation \\(T <: S\\) or \\(S :> T\\) to denote that \\(T\\) is subtype of \\(S\\) . The subtype relationship is transitive, i.e., if \\(S <: T\\) and \\(T <: U\\) , then \\(S <: U\\) . It is also reflexive, for any type \\(S\\) , \\(S <: S\\) . We also use the term supertype to denote the reversed relationship: if \\(T\\) is a subtype of \\(S\\) , then \\(S\\) is a supertype of \\(T\\) .","title":"Subtypes"},{"location":"02-type.html#subtyping-between-java-primitive-types","text":"Consider the range of values that the primitive types can take, Java defines the following subtyping relationship: byte <: short <: int <: long <: float <: double char <: int Valid subtype relationship is part of what the Java compiler checks for when it compiles. Consider the following example: 1 2 3 4 double d = 5.0 ; int i = 5 ; d = i ; i = d ; // error Line 4 above would lead to an error: 1 | incompatible types: possible lossy conversion from double to int but Line 3 is OK. This example shows how subtyping applies to type checking. Java allows a variable of type \\(T\\) to hold a value from a variable of type \\(S\\) only if \\(S <: T\\) . This step is called widening type conversion . Such conversion can happen during assignment or parameter passing.","title":"Subtyping Between Java Primitive Types"},{"location":"02-type.html#additional-readings","text":"Java Tutorial: Primitive Data Types and other Language Basics","title":"Additional Readings"},{"location":"03-function.html","text":"Unit 3: Functions After reading this unit, students should understand the importance of function as a programming constructor and how it helps to reduce complexity and mitigate bugs. be aware of two different roles a programmer can play: the implementer and the client understand the concept of abstraction barrier as a wall between the client and the implementer, including in the context of a function. Function as an Abstraction over Computation Another important abstraction provided by a programming language is the function (or procedure ). This abstraction allows programmers to group a set of instructions and give it a name. The named set of instructions may take one or more variables as input parameters, and return one or more values. Like all other abstractions, defining functions allow us to think at a higher conceptual level. By composing functions at increasingly higher level of abstractions, we can build programs with increasing level of complexity. Functions help us deal with complexity in a few ways: Functions allow programmers to compartmentalize computation and its effects. We can isolate the complexity to within its body: the intermediate variables exists only as local variables that has no effect outside of the function. A function only interacts with the rest of the code through its parameters and return value, and so, reduces the dependencies between variables to these well-defined interactions. Such compartmentalization reduces the complexity of code. Functions allow programmers to hide how a task is performed. The caller of the function only needs to worry about what the function does. By hiding the details of how , we gain two weapons against code complexity. First, we reduce the amount of information that we need to communicate among programmers. A fellow programmer only needs to read the documentation to understand what the parameters are for, what the return values are. There is no need for a fellow programmer to know about the intermediate variables or the internal computation used to implement the functions. Second, as the design and requirement evolve, the implementation of a function may change. But, as long as the parameters and the return value of a function remains the same, the caller of the function does not have to update the code accordingly. Reducing the need to change as the software evolves reduces the chances of introducing bugs accordingly. Functions allows us to reduce repetition in our code through code reuse . If we have the same computation that we need to perform repeatedly on different values , we can construct these computations as functions, replacing the values with parameters, and pass in the values as arguments to the function. This approach reduces the amount of boiler-plate code and has two major benefits in reducing code complexity and bugs. First, it makes the code more succinct, and therefore easier to read and understand. Second, it reduces the number of places in our code that we need to modify as the software evolves, and therefore, decreases the chance of introducing new bugs. Abstraction Barrier We can imagine an abstraction barrier between the code that calls a function and the code that defines the function body. Above the barrier, the concern is about using the function to perform a task, while below the barrier, the concern is about how to perform the task. While many of you are used to writing a program solo, in practice, you rarely write a program with contributions from only a single person. The abstraction barrier separates the role of the programmer into two: (i) an implementer , who provides the implementation of the function, and (ii) a client , which uses the function to perform the task. Part of the aim in CS2030/S is to switch your mindset into thinking in terms of these two roles. The abstraction barrier thus enforces a separation of concerns between the two roles. The concept of abstraction barrier applies not only to a function, but it can be applied to different levels of abstraction as well. We will see how it is used for a higher-level of abstraction in the next unit.","title":"3. Functions"},{"location":"03-function.html#unit-3-functions","text":"After reading this unit, students should understand the importance of function as a programming constructor and how it helps to reduce complexity and mitigate bugs. be aware of two different roles a programmer can play: the implementer and the client understand the concept of abstraction barrier as a wall between the client and the implementer, including in the context of a function.","title":"Unit 3: Functions"},{"location":"03-function.html#function-as-an-abstraction-over-computation","text":"Another important abstraction provided by a programming language is the function (or procedure ). This abstraction allows programmers to group a set of instructions and give it a name. The named set of instructions may take one or more variables as input parameters, and return one or more values. Like all other abstractions, defining functions allow us to think at a higher conceptual level. By composing functions at increasingly higher level of abstractions, we can build programs with increasing level of complexity. Functions help us deal with complexity in a few ways: Functions allow programmers to compartmentalize computation and its effects. We can isolate the complexity to within its body: the intermediate variables exists only as local variables that has no effect outside of the function. A function only interacts with the rest of the code through its parameters and return value, and so, reduces the dependencies between variables to these well-defined interactions. Such compartmentalization reduces the complexity of code. Functions allow programmers to hide how a task is performed. The caller of the function only needs to worry about what the function does. By hiding the details of how , we gain two weapons against code complexity. First, we reduce the amount of information that we need to communicate among programmers. A fellow programmer only needs to read the documentation to understand what the parameters are for, what the return values are. There is no need for a fellow programmer to know about the intermediate variables or the internal computation used to implement the functions. Second, as the design and requirement evolve, the implementation of a function may change. But, as long as the parameters and the return value of a function remains the same, the caller of the function does not have to update the code accordingly. Reducing the need to change as the software evolves reduces the chances of introducing bugs accordingly. Functions allows us to reduce repetition in our code through code reuse . If we have the same computation that we need to perform repeatedly on different values , we can construct these computations as functions, replacing the values with parameters, and pass in the values as arguments to the function. This approach reduces the amount of boiler-plate code and has two major benefits in reducing code complexity and bugs. First, it makes the code more succinct, and therefore easier to read and understand. Second, it reduces the number of places in our code that we need to modify as the software evolves, and therefore, decreases the chance of introducing new bugs.","title":"Function as an Abstraction over Computation"},{"location":"03-function.html#abstraction-barrier","text":"We can imagine an abstraction barrier between the code that calls a function and the code that defines the function body. Above the barrier, the concern is about using the function to perform a task, while below the barrier, the concern is about how to perform the task. While many of you are used to writing a program solo, in practice, you rarely write a program with contributions from only a single person. The abstraction barrier separates the role of the programmer into two: (i) an implementer , who provides the implementation of the function, and (ii) a client , which uses the function to perform the task. Part of the aim in CS2030/S is to switch your mindset into thinking in terms of these two roles. The abstraction barrier thus enforces a separation of concerns between the two roles. The concept of abstraction barrier applies not only to a function, but it can be applied to different levels of abstraction as well. We will see how it is used for a higher-level of abstraction in the next unit.","title":"Abstraction Barrier"},{"location":"04-encapsulation.html","text":"Unit 4: Encapsulation After reading this unit, students should understand composite data type as a even-higher level abstraction over variables understand encapsulation as an object-oriented (OO) principle understand the meaning of class, object, fields, methods, in the context of OO programming be able to define a class and instantiate one as an object in Java appreciate OO as a natural way to model the real world in programs understand reference types in Java and its difference from the primitive types Abstraction: Composite Data Type Just like functions allow programmers to group instructions, give it a name, and refer to it later, a composite data type allows programmers to group primitive types together, give it a name (a new type), and refer to it later. This is another powerful abstraction in programming languages that help us to think at a higher conceptual level without worrying about the details. Commonly used examples are mathematical objects such as complex numbers, 2D data points, multi-dimensional vectors, circles, etc, or everyday objects such as a person, a product, etc. Defining composite data type allows programmers to abstract away (and be separated from the concern of) how a complex data type is represented. For instance, a circle on a 2D plane can be represented by the center ( x , y ) and its radius r , or it can be represented by the top left corner ( x , y ) and the width w of the bounding square. In C, we build a composite data type with struct . For example, 1 2 3 4 typedef struct { double x , y ; // (x,y) coordinate of the center. double r ; // radius } circle ; Once we have the struct defined, we are not completely shielded from its representation, until we write a set of functions that operates on the circle composite type. For instance, 1 2 3 double circle_area ( circle c ) { ... }; bool circle_contains_point ( circle c , double x , double y ) { ... }; : Implementing these functions requires knowledge of how a circle is represented. Once the set of functions that operates on and manipulates circles is available, we can use the circle type without worrying about the internal representation. If we decide to change the representation of a circle, then only the set of functions that operates on a circle type need to be changed, but not the code that uses circles to do other things. In other words, the representation of the circle and the set of functions that operation on and manipulate circles, fall on the same side of the abstraction barrier. Abstraction: Class and Object (or, Encapsulation) We can further bundle the composite data type and its associated functions on the same side of the abstraction barrier together, into another abstraction called a class . A class is a data type with a group of functions associated with it. We call the functions as methods and the data in the class as fields (or members , or states , or attributes 1 ). A well-designed class maintains the abstraction barrier, properly wraps the barrier around the internal representation and implementation, and exposes just the right method interface for others to use. The concept of keeping all the data and functions operating on the data related to a composite data type together within an abstraction barrier is called encapsulation . Let's see how we can encapsulate the fields and methods associated together, using Circle as an example, in Java. 1 2 3 4 5 6 7 8 9 10 // Circle v0.1 class Circle { double x ; double y ; double r ; double getArea () { return 3.141592653589793 * r * r ; } } The code above defines a new class using the keyword class , give it a name Circle 2 , followed by a block listing the member variables (with types) and the function definitions. Just like we can create variables of a given type, we can create objects of a given class. Objects are instances of a class, each allowing the same methods to be called, and each containing the same set of variables of the same types, but (possibly) storing different values. In Java, the keyword new creates an object of a given class. For instance, to create a Circle object, we can use 1 Circle c = new Circle (); To access the fields and the methods, we use the . notation. For example, object.field or object.method(..) . For instance, 1 2 c . r = 10 ; // set the radius to 10 c . getArea (); // return 314.1592653589793 Object-Oriented Programming A program written in an object-oriented language such as Java consists of classes, with one main class as the entry point. One can view a running object-oriented (or OO) program as something that instantiates objects of different classes and orchestrates their interactions with each other by calling each others' methods. One could argue that an object-oriented way of writing programs is much more natural, as it mirrors our world more closely. If we look around us, we see objects all around us, and each object has certain properties, exhibits certain behavior, and they allow certain actions. We interact with the objects through their interfaces, and we rarely need to know the internals of the objects we used every day (unless we try to repair them) 3 . To model a problem in an object-oriented manner, we typically model the nouns as classes and objects, the properties or relationships among the classes as fields, and the verbs or actions of the corresponding objects as methods. Reference Types in Java We mentioned in Unit 2 that there are two kinds of types in Java. You have been introduced to the primitive types. Everything else in Java is a reference type. The Circle class is an example of a reference type. Unlike primitive variables, which never share the value, a reference variable stores only the reference to the value, and therefore two reference variables can share the same value. For instance, 1 2 3 4 5 Circle c1 = new Circle (); Circle c2 = c1 ; System . out . println ( c2 . r ); // print 0 c1 . r = 10.0 ; System . out . println ( c2 . r ); // print 10.0 The behavior above is due to the variables c1 and c2 referencing to the same Circle object in the memory. Therefore, changing the field r of c1 causes the field r of c2 to change as well. Special Reference Value: null Any reference variable that is not initialized will have the special reference value null . A common error for beginners is to declare a reference variable and try to use it without instantiating an object: 1 2 Circle c1 ; c1 . r = 10.0 ; // error Line 2 would lead to a run-time error message 1 | Exception java.lang.NullPointerException Remember to always instantiate a reference variable before using it. Further Readings Oracle's Java Tutorial on Classes and Objects Computer scientists just could not decide what to call this :( \u21a9 As a convention, we use PascalCase for class name and camelCase for variable and method names in Java. \u21a9 This is a standard analogy in an OOP textbook. In practice, however, we often have to write programs that include abstract concepts with no tangible real-world analogy as classes. \u21a9","title":"4. Encapsulation"},{"location":"04-encapsulation.html#unit-4-encapsulation","text":"After reading this unit, students should understand composite data type as a even-higher level abstraction over variables understand encapsulation as an object-oriented (OO) principle understand the meaning of class, object, fields, methods, in the context of OO programming be able to define a class and instantiate one as an object in Java appreciate OO as a natural way to model the real world in programs understand reference types in Java and its difference from the primitive types","title":"Unit 4: Encapsulation"},{"location":"04-encapsulation.html#abstraction-composite-data-type","text":"Just like functions allow programmers to group instructions, give it a name, and refer to it later, a composite data type allows programmers to group primitive types together, give it a name (a new type), and refer to it later. This is another powerful abstraction in programming languages that help us to think at a higher conceptual level without worrying about the details. Commonly used examples are mathematical objects such as complex numbers, 2D data points, multi-dimensional vectors, circles, etc, or everyday objects such as a person, a product, etc. Defining composite data type allows programmers to abstract away (and be separated from the concern of) how a complex data type is represented. For instance, a circle on a 2D plane can be represented by the center ( x , y ) and its radius r , or it can be represented by the top left corner ( x , y ) and the width w of the bounding square. In C, we build a composite data type with struct . For example, 1 2 3 4 typedef struct { double x , y ; // (x,y) coordinate of the center. double r ; // radius } circle ; Once we have the struct defined, we are not completely shielded from its representation, until we write a set of functions that operates on the circle composite type. For instance, 1 2 3 double circle_area ( circle c ) { ... }; bool circle_contains_point ( circle c , double x , double y ) { ... }; : Implementing these functions requires knowledge of how a circle is represented. Once the set of functions that operates on and manipulates circles is available, we can use the circle type without worrying about the internal representation. If we decide to change the representation of a circle, then only the set of functions that operates on a circle type need to be changed, but not the code that uses circles to do other things. In other words, the representation of the circle and the set of functions that operation on and manipulate circles, fall on the same side of the abstraction barrier.","title":"Abstraction: Composite Data Type"},{"location":"04-encapsulation.html#abstraction-class-and-object-or-encapsulation","text":"We can further bundle the composite data type and its associated functions on the same side of the abstraction barrier together, into another abstraction called a class . A class is a data type with a group of functions associated with it. We call the functions as methods and the data in the class as fields (or members , or states , or attributes 1 ). A well-designed class maintains the abstraction barrier, properly wraps the barrier around the internal representation and implementation, and exposes just the right method interface for others to use. The concept of keeping all the data and functions operating on the data related to a composite data type together within an abstraction barrier is called encapsulation . Let's see how we can encapsulate the fields and methods associated together, using Circle as an example, in Java. 1 2 3 4 5 6 7 8 9 10 // Circle v0.1 class Circle { double x ; double y ; double r ; double getArea () { return 3.141592653589793 * r * r ; } } The code above defines a new class using the keyword class , give it a name Circle 2 , followed by a block listing the member variables (with types) and the function definitions. Just like we can create variables of a given type, we can create objects of a given class. Objects are instances of a class, each allowing the same methods to be called, and each containing the same set of variables of the same types, but (possibly) storing different values. In Java, the keyword new creates an object of a given class. For instance, to create a Circle object, we can use 1 Circle c = new Circle (); To access the fields and the methods, we use the . notation. For example, object.field or object.method(..) . For instance, 1 2 c . r = 10 ; // set the radius to 10 c . getArea (); // return 314.1592653589793","title":"Abstraction: Class and Object (or, Encapsulation)"},{"location":"04-encapsulation.html#object-oriented-programming","text":"A program written in an object-oriented language such as Java consists of classes, with one main class as the entry point. One can view a running object-oriented (or OO) program as something that instantiates objects of different classes and orchestrates their interactions with each other by calling each others' methods. One could argue that an object-oriented way of writing programs is much more natural, as it mirrors our world more closely. If we look around us, we see objects all around us, and each object has certain properties, exhibits certain behavior, and they allow certain actions. We interact with the objects through their interfaces, and we rarely need to know the internals of the objects we used every day (unless we try to repair them) 3 . To model a problem in an object-oriented manner, we typically model the nouns as classes and objects, the properties or relationships among the classes as fields, and the verbs or actions of the corresponding objects as methods.","title":"Object-Oriented Programming"},{"location":"04-encapsulation.html#reference-types-in-java","text":"We mentioned in Unit 2 that there are two kinds of types in Java. You have been introduced to the primitive types. Everything else in Java is a reference type. The Circle class is an example of a reference type. Unlike primitive variables, which never share the value, a reference variable stores only the reference to the value, and therefore two reference variables can share the same value. For instance, 1 2 3 4 5 Circle c1 = new Circle (); Circle c2 = c1 ; System . out . println ( c2 . r ); // print 0 c1 . r = 10.0 ; System . out . println ( c2 . r ); // print 10.0 The behavior above is due to the variables c1 and c2 referencing to the same Circle object in the memory. Therefore, changing the field r of c1 causes the field r of c2 to change as well.","title":"Reference Types in Java"},{"location":"04-encapsulation.html#special-reference-value-null","text":"Any reference variable that is not initialized will have the special reference value null . A common error for beginners is to declare a reference variable and try to use it without instantiating an object: 1 2 Circle c1 ; c1 . r = 10.0 ; // error Line 2 would lead to a run-time error message 1 | Exception java.lang.NullPointerException Remember to always instantiate a reference variable before using it.","title":"Special Reference Value: null"},{"location":"04-encapsulation.html#further-readings","text":"Oracle's Java Tutorial on Classes and Objects Computer scientists just could not decide what to call this :( \u21a9 As a convention, we use PascalCase for class name and camelCase for variable and method names in Java. \u21a9 This is a standard analogy in an OOP textbook. In practice, however, we often have to write programs that include abstract concepts with no tangible real-world analogy as classes. \u21a9","title":"Further Readings"},{"location":"05-infohiding.html","text":"Unit 5: Information Hiding After taking this unit, students should: understand the drawback of breaking the abstraction barrier understand the concept of information hiding to enforce the abstraction barrier understand how Java uses access modifiers to enforce information hiding understand what is a constructor and how to write one in Java Breaking the Abstraction Barrier In the ideal case, the code above the abstraction barrier would just call the provided interface to use the composite data type. There, however, may be cases where a programmer may intentionally or accidentally break the abstraction barrier. Consider the case of Circle above, where we modify the radius r directly with c.r = 10 . In doing so, we, as the client to Circle , make an explicit assumption of how Circle implements a circle. The implementation details have been leaked outside the abstraction barrier. Now, if the implementer wishes to change the representation of the Circle , to say, store the diameter, instead. This small implementation change would invalidate the code that the client has written! The client will have to carefully change all the code that makes the assumption, and modify accordingly, increasing the chances of introducing a bug. Data Hiding Many OO languages allow programmers to explicitly specify if a field or a method can be accessed from outside the abstraction barrier. Java, for instance, supports private and public access modifiers. A field or a method that is declared as private cannot be accessed from outside the class, and can only be accessed within the class. On the other hand, as you can guess, a public field or method can be accessed, modified, or invoked from outside the class. Such a mechanism to protect the abstraction barrier from being broken is called data hiding or information hiding . This protection is enforced by the compiler at compile time. In our original Circle class (v0.1) in Unit 4 , we did not specify any access modifier -- this amounts to using the default modifier, the meaning of which is not our concern right now 1 For a start, we will explicitly indicate private or public for all our methods and fields. 1 2 3 4 5 6 7 8 9 10 // Circle v0.2 class Circle { private double x ; private double y ; private double r ; public double getArea () { return 3.141592653589793 * r * r ; }; } Now the fields x , y , and r are hidden behind the abstraction barrier of the class Circle . Note that these fields are not accessible and modifiable outside of the class Circle , but they can be accessed and modified within Circle (inside the abstraction barrier), such as in the methods getArea . Breaking Python's Abstraction Barrier Python tries to prevent accidental access to internal representation by having a convention of prefixing the internal variables with _ (one underscore) or __ (two underscores). This method, however, does not prevent a lazy programmer from directly accessing the variables and possibly planting a bug/error that will surface later. Constructors With data hiding, we completely isolate the internal representation of a class using an abstraction barrier. But, with no way for the client of the class to modify the fields directly, how can the client initialize the fields in a class? To get around this, it is common for a class to provide methods to initialize these internal fields. A method that initializes an object is called a constructor . A constructor method is a special method within the class. It cannot be called directly but is invoked automatically when an object is instantiated. In Java, a constructor method has the same name as the class and has no return type . A constructor can take in arguments just like other functions. Let's add a constructor to our Circle class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Circle v0.3 class Circle { private double x ; private double y ; private double r ; public Circle ( double x , double y , double r ) { this . x = x ; this . y = y ; this . r = r ; } public double getArea () { return 3.141592653589793 * this . r * this . r ; }; } Now, to create a Circle object, we need to pass in three arguments: 1 Circle c = new Circle ( 0.0 , 0.5 , 10.0 ); Constructor in Python and JavaScript In Python, the constructor is the __init__ method. In JavaScript, the constructor is simply called constructor . The this Keyword The code above also introduces the this keyword. this is a reference variable that refers back to self, and is used to distinguish between two variables of the same name. In the example above, this.x = x means we want to set the field x of this object to the parameter x passed into the constructor. Now that you have been introduced to this , we have also updated the method body of getArea and replaced r with this.r . Although there is nothing syntactically incorrect about using r , sticking to the idiom of referring to members through the this reference makes the code easier to understand to readers. We are making it explicit that we are referring to a field in the class, rather than a local variable or a parameter. The other access modifier is protected . Again, we do not want to worry about this modifier for now. \u21a9","title":"5. Information Hiding"},{"location":"05-infohiding.html#unit-5-information-hiding","text":"After taking this unit, students should: understand the drawback of breaking the abstraction barrier understand the concept of information hiding to enforce the abstraction barrier understand how Java uses access modifiers to enforce information hiding understand what is a constructor and how to write one in Java","title":"Unit 5: Information Hiding"},{"location":"05-infohiding.html#breaking-the-abstraction-barrier","text":"In the ideal case, the code above the abstraction barrier would just call the provided interface to use the composite data type. There, however, may be cases where a programmer may intentionally or accidentally break the abstraction barrier. Consider the case of Circle above, where we modify the radius r directly with c.r = 10 . In doing so, we, as the client to Circle , make an explicit assumption of how Circle implements a circle. The implementation details have been leaked outside the abstraction barrier. Now, if the implementer wishes to change the representation of the Circle , to say, store the diameter, instead. This small implementation change would invalidate the code that the client has written! The client will have to carefully change all the code that makes the assumption, and modify accordingly, increasing the chances of introducing a bug.","title":"Breaking the Abstraction Barrier"},{"location":"05-infohiding.html#data-hiding","text":"Many OO languages allow programmers to explicitly specify if a field or a method can be accessed from outside the abstraction barrier. Java, for instance, supports private and public access modifiers. A field or a method that is declared as private cannot be accessed from outside the class, and can only be accessed within the class. On the other hand, as you can guess, a public field or method can be accessed, modified, or invoked from outside the class. Such a mechanism to protect the abstraction barrier from being broken is called data hiding or information hiding . This protection is enforced by the compiler at compile time. In our original Circle class (v0.1) in Unit 4 , we did not specify any access modifier -- this amounts to using the default modifier, the meaning of which is not our concern right now 1 For a start, we will explicitly indicate private or public for all our methods and fields. 1 2 3 4 5 6 7 8 9 10 // Circle v0.2 class Circle { private double x ; private double y ; private double r ; public double getArea () { return 3.141592653589793 * r * r ; }; } Now the fields x , y , and r are hidden behind the abstraction barrier of the class Circle . Note that these fields are not accessible and modifiable outside of the class Circle , but they can be accessed and modified within Circle (inside the abstraction barrier), such as in the methods getArea . Breaking Python's Abstraction Barrier Python tries to prevent accidental access to internal representation by having a convention of prefixing the internal variables with _ (one underscore) or __ (two underscores). This method, however, does not prevent a lazy programmer from directly accessing the variables and possibly planting a bug/error that will surface later.","title":"Data Hiding"},{"location":"05-infohiding.html#constructors","text":"With data hiding, we completely isolate the internal representation of a class using an abstraction barrier. But, with no way for the client of the class to modify the fields directly, how can the client initialize the fields in a class? To get around this, it is common for a class to provide methods to initialize these internal fields. A method that initializes an object is called a constructor . A constructor method is a special method within the class. It cannot be called directly but is invoked automatically when an object is instantiated. In Java, a constructor method has the same name as the class and has no return type . A constructor can take in arguments just like other functions. Let's add a constructor to our Circle class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Circle v0.3 class Circle { private double x ; private double y ; private double r ; public Circle ( double x , double y , double r ) { this . x = x ; this . y = y ; this . r = r ; } public double getArea () { return 3.141592653589793 * this . r * this . r ; }; } Now, to create a Circle object, we need to pass in three arguments: 1 Circle c = new Circle ( 0.0 , 0.5 , 10.0 ); Constructor in Python and JavaScript In Python, the constructor is the __init__ method. In JavaScript, the constructor is simply called constructor .","title":"Constructors"},{"location":"05-infohiding.html#the-this-keyword","text":"The code above also introduces the this keyword. this is a reference variable that refers back to self, and is used to distinguish between two variables of the same name. In the example above, this.x = x means we want to set the field x of this object to the parameter x passed into the constructor. Now that you have been introduced to this , we have also updated the method body of getArea and replaced r with this.r . Although there is nothing syntactically incorrect about using r , sticking to the idiom of referring to members through the this reference makes the code easier to understand to readers. We are making it explicit that we are referring to a field in the class, rather than a local variable or a parameter. The other access modifier is protected . Again, we do not want to worry about this modifier for now. \u21a9","title":"The this Keyword"},{"location":"06-tell-dont-ask.html","text":"Unit 6: Tell, Don't Ask After taking this unit, students should: understand what accessor and mutator are used for, and why not to use them understand the principle of \"Tell, Don't Ask\" Accessors and Mutators Similar to providing constructors, a class should also provide methods to retrieve or modify the properties of the object. These methods are called the accessor (or getter ) or mutator (or setter ). The use of accessor and mutator methods is a bit controversial. Suppose that we provide an accessor method and a mutator method for every private field, then we are exposing the internal representation, therefore breaking the encapsulation. For instance: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // Circle v0.4 class Circle { private double x ; private double y ; private double r ; public Circle ( double x , double y , double r ) { this . x = x ; this . y = y ; this . r = r ; } public double getX () { return this . x ; } public void setX ( double x ) { this . x = x ; } public double getY () { return this . y ; } public void setY ( double y ) { this . y = y ; } public double getR () { return this . r ; } public void setR ( double r ) { this . r = r ; } public double getArea () { return 3.141592653589793 * this . r * this . r ; }; } The \"Tell Don't Ask\" Principle The mutators and accessors above are pretty pointless. If we need to know the internal and do something with it, then we are breaking the abstraction barrier. The right approach is to implement a method within the class that does whatever we want the class to do. For instance, suppose that we want to check if a given point (x,y) calls within the circle, one approach would be: 1 2 3 4 double cX = c . getX (); double cY = c . getY (); double r = c . getR (); boolean isInCircle = (( x - cX ) * ( x - cX ) + ( y - cY ) * ( y - cY )) <= r * r ; where c is a Circle object. A better approach would be to add a new boolean method in the Circle class, and call it instead: 1 boolean isInCircle = c . contain ( x , y ); The better approach involves writing a few more lines of code to implement the method, but it keeps the encapsulation intact. If one fine day, the implementer of Circle decided to change the representation of the circle and remove the direct accessors to the fields, then only the implementer needs to change the implementation of contain . The client does not have to change anything. The principle around which we can think about this is the \"Tell, Don't Ask\" principle. The client should tell a Circle object what to do (compute the circumference), instead of asking \"what is your radius?\" to get the value of a field then perform the computation on the object's behalf. While there are situations where we can't avoid using accessor or modifier in a class, for beginner OO programmers like yourself, it is better to not define classes with any accessor and modifier to the private fields, and forces yourselves to think in the OO way -- to tell an object what task to perform as a client, and then implement this task within the class as a method as the implementer. Further Reading Tell Don't Ask by Martin Fowler Why getters and setters are evil , by Allen Holub, JavaWorld Getters and setters are evil. Period , by Yegor Bygayenko.","title":"6. Tell, Don't Ask"},{"location":"06-tell-dont-ask.html#unit-6-tell-dont-ask","text":"After taking this unit, students should: understand what accessor and mutator are used for, and why not to use them understand the principle of \"Tell, Don't Ask\"","title":"Unit 6: Tell, Don't Ask"},{"location":"06-tell-dont-ask.html#accessors-and-mutators","text":"Similar to providing constructors, a class should also provide methods to retrieve or modify the properties of the object. These methods are called the accessor (or getter ) or mutator (or setter ). The use of accessor and mutator methods is a bit controversial. Suppose that we provide an accessor method and a mutator method for every private field, then we are exposing the internal representation, therefore breaking the encapsulation. For instance: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // Circle v0.4 class Circle { private double x ; private double y ; private double r ; public Circle ( double x , double y , double r ) { this . x = x ; this . y = y ; this . r = r ; } public double getX () { return this . x ; } public void setX ( double x ) { this . x = x ; } public double getY () { return this . y ; } public void setY ( double y ) { this . y = y ; } public double getR () { return this . r ; } public void setR ( double r ) { this . r = r ; } public double getArea () { return 3.141592653589793 * this . r * this . r ; }; }","title":"Accessors and Mutators"},{"location":"06-tell-dont-ask.html#the-tell-dont-ask-principle","text":"The mutators and accessors above are pretty pointless. If we need to know the internal and do something with it, then we are breaking the abstraction barrier. The right approach is to implement a method within the class that does whatever we want the class to do. For instance, suppose that we want to check if a given point (x,y) calls within the circle, one approach would be: 1 2 3 4 double cX = c . getX (); double cY = c . getY (); double r = c . getR (); boolean isInCircle = (( x - cX ) * ( x - cX ) + ( y - cY ) * ( y - cY )) <= r * r ; where c is a Circle object. A better approach would be to add a new boolean method in the Circle class, and call it instead: 1 boolean isInCircle = c . contain ( x , y ); The better approach involves writing a few more lines of code to implement the method, but it keeps the encapsulation intact. If one fine day, the implementer of Circle decided to change the representation of the circle and remove the direct accessors to the fields, then only the implementer needs to change the implementation of contain . The client does not have to change anything. The principle around which we can think about this is the \"Tell, Don't Ask\" principle. The client should tell a Circle object what to do (compute the circumference), instead of asking \"what is your radius?\" to get the value of a field then perform the computation on the object's behalf. While there are situations where we can't avoid using accessor or modifier in a class, for beginner OO programmers like yourself, it is better to not define classes with any accessor and modifier to the private fields, and forces yourselves to think in the OO way -- to tell an object what task to perform as a client, and then implement this task within the class as a method as the implementer.","title":"The \"Tell Don't Ask\" Principle"},{"location":"06-tell-dont-ask.html#further-reading","text":"Tell Don't Ask by Martin Fowler Why getters and setters are evil , by Allen Holub, JavaWorld Getters and setters are evil. Period , by Yegor Bygayenko.","title":"Further Reading"},{"location":"07-static-field.html","text":"Unit 7: Class Fields After this unit, students should: understand the difference between instance fields and class fields understand the meaning of keywords final and static in the context of a field be able to define and use a class field be able to use import to access classes from the Java standard libraries Class Fields Let's revisit the following implementation of Circle . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Circle v0.3 class Circle { private double x ; private double y ; private double r ; public Circle ( double x , double y , double r ) { this . x = x ; this . y = y ; this . r = r ; } public double getArea () { return 3.141592653589793 * this . r * this . r ; }; } In the code above, we use the constant \\(\\pi\\) but hardcoded it as 3.141592653589793. Hardcoding such a magic number is a no-no in terms of coding style. This constant can appear in more than one places. If we hardcode such a number and want to change its precision later, we would need to trace down and change every occurrence. Every time we need to use \\(\\pi\\) , we have to remember or look up what is the precision that we use. Not only does this practice introduce more work, it is also likely to introduce bugs. In C, we define \\(\\pi\\) as a macro constant M_PI . But how should we do this in Java? This is where the ideal that a program consists of only objects with internal states that communicate with each other feel a bit constraining. The constant \\(\\pi\\) is universal, and does not really belong to any object (the value of \\(\\pi\\) is the same for every circle!). Another example is the method sqrt() that computes the square root of a given number. sqrt is a general function that is not associated with any object as well. A solution to this is to associate these global values and functions with a class instead of with an object . For instance. Java predefines a java.lang.Math class 1 that is populated with constants PI and E (for Euler's number \\(e\\) ), along with a long list of mathematical functions. To associate a method or a field with a class in Java, we declare them with the static keyword. We can additionally add a keyword final to indicate that the value of the field will not change and public to indicate that the field is accessible from outside the class. In short, the combination of public static final modifiers is used for constant values in Java. 1 2 3 4 5 6 class Math { : public static final double PI = 3.141592653589793 ; : : } We call these static fields that are associated with a class as class fields , and fields that are associated with an object as instance fields . Note that, a static class field needs not be final and it needs not be public . Class fields are useful for storing pre-computed values or configuration parameters associated to a class rather than individual objects. Accessing Class Fields A class field behaves just like a global variable and can be access in the code, anywhere the class can be accessed. Since a class field is associated with a class rather than an object, we access it through its class name . To use the static class field PI , for instance, we have to say java.lang.Math.PI . 1 2 3 public double getArea () { return java . lang . Math . PI * this . r * this . r ; }; A more common way, however, is to use import statements at the top of the program. If we have this line: 1 import java.lang.Math ; Then, we can save some typing and write: 1 2 3 public double getArea () { return Math . PI * this . r * this . r ; }; Class Fields and Methods in Python Note that, in Python, any variable declared within a class block is a class field: 1 2 3 class Circle : x = 0 y = 0 In the above example, x and y are class fields, not instance fields. Example: The Circle class Now, let revise our Circle class to improve the code and make it a little more complete. We now add in comments for each method and variable as well, as we always should. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // version 0.4 import java.lang.Math ; /** * A Circle object encapsulates a circle on a 2D plane. */ class Circle { private double x ; // x-coordinate of the center private double y ; // y-coordinate of the center private double r ; // the length of the radius /** * Create a circle centered on (x, y) with given radius */ public Circle ( double x , double y , double r ) { this . x = x ; this . y = y ; this . r = r ; } /** * Return the area of the circle. */ public double getArea () { return Math . PI * this . r * this . r ; } /** * Return true if the given point (x, y) is within the circle. */ public boolean contains ( double x , double y ) { return false ; // TODO: Left as an exercise } } The class Math is provided by the package java.lang in Java. A package is simply a set of related classes (and interfaces, but I have not told you what is an interface yet). To use this class, we need to add the line import java.lang.Math at the beginning of our program. \u21a9","title":"7. Class Fields"},{"location":"07-static-field.html#unit-7-class-fields","text":"After this unit, students should: understand the difference between instance fields and class fields understand the meaning of keywords final and static in the context of a field be able to define and use a class field be able to use import to access classes from the Java standard libraries","title":"Unit 7: Class Fields"},{"location":"07-static-field.html#class-fields","text":"Let's revisit the following implementation of Circle . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Circle v0.3 class Circle { private double x ; private double y ; private double r ; public Circle ( double x , double y , double r ) { this . x = x ; this . y = y ; this . r = r ; } public double getArea () { return 3.141592653589793 * this . r * this . r ; }; } In the code above, we use the constant \\(\\pi\\) but hardcoded it as 3.141592653589793. Hardcoding such a magic number is a no-no in terms of coding style. This constant can appear in more than one places. If we hardcode such a number and want to change its precision later, we would need to trace down and change every occurrence. Every time we need to use \\(\\pi\\) , we have to remember or look up what is the precision that we use. Not only does this practice introduce more work, it is also likely to introduce bugs. In C, we define \\(\\pi\\) as a macro constant M_PI . But how should we do this in Java? This is where the ideal that a program consists of only objects with internal states that communicate with each other feel a bit constraining. The constant \\(\\pi\\) is universal, and does not really belong to any object (the value of \\(\\pi\\) is the same for every circle!). Another example is the method sqrt() that computes the square root of a given number. sqrt is a general function that is not associated with any object as well. A solution to this is to associate these global values and functions with a class instead of with an object . For instance. Java predefines a java.lang.Math class 1 that is populated with constants PI and E (for Euler's number \\(e\\) ), along with a long list of mathematical functions. To associate a method or a field with a class in Java, we declare them with the static keyword. We can additionally add a keyword final to indicate that the value of the field will not change and public to indicate that the field is accessible from outside the class. In short, the combination of public static final modifiers is used for constant values in Java. 1 2 3 4 5 6 class Math { : public static final double PI = 3.141592653589793 ; : : } We call these static fields that are associated with a class as class fields , and fields that are associated with an object as instance fields . Note that, a static class field needs not be final and it needs not be public . Class fields are useful for storing pre-computed values or configuration parameters associated to a class rather than individual objects.","title":"Class Fields"},{"location":"07-static-field.html#accessing-class-fields","text":"A class field behaves just like a global variable and can be access in the code, anywhere the class can be accessed. Since a class field is associated with a class rather than an object, we access it through its class name . To use the static class field PI , for instance, we have to say java.lang.Math.PI . 1 2 3 public double getArea () { return java . lang . Math . PI * this . r * this . r ; }; A more common way, however, is to use import statements at the top of the program. If we have this line: 1 import java.lang.Math ; Then, we can save some typing and write: 1 2 3 public double getArea () { return Math . PI * this . r * this . r ; }; Class Fields and Methods in Python Note that, in Python, any variable declared within a class block is a class field: 1 2 3 class Circle : x = 0 y = 0 In the above example, x and y are class fields, not instance fields.","title":"Accessing Class Fields"},{"location":"07-static-field.html#example-the-circle-class","text":"Now, let revise our Circle class to improve the code and make it a little more complete. We now add in comments for each method and variable as well, as we always should. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // version 0.4 import java.lang.Math ; /** * A Circle object encapsulates a circle on a 2D plane. */ class Circle { private double x ; // x-coordinate of the center private double y ; // y-coordinate of the center private double r ; // the length of the radius /** * Create a circle centered on (x, y) with given radius */ public Circle ( double x , double y , double r ) { this . x = x ; this . y = y ; this . r = r ; } /** * Return the area of the circle. */ public double getArea () { return Math . PI * this . r * this . r ; } /** * Return true if the given point (x, y) is within the circle. */ public boolean contains ( double x , double y ) { return false ; // TODO: Left as an exercise } } The class Math is provided by the package java.lang in Java. A package is simply a set of related classes (and interfaces, but I have not told you what is an interface yet). To use this class, we need to add the line import java.lang.Math at the beginning of our program. \u21a9","title":"Example: The Circle class"},{"location":"08-static-method.html","text":"Unit 8: Class Methods After this unit, students should: understand the differences between instance methods and class methods be able to define and use a class method know that the main method is the entry point to a Java program the modifies and parameters required for a main method Let's suppose that, in our program, we wish to assign a unique integer identifier to every Circle object ever created. We can do this with the additions below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Circle { private double x ; // x-coordinate of the center private double y ; // y-coordinate of the center private double r ; // the length of the radius private final int id ; // identifier private static int lastId = 0 ; // the id of the latest circle instance /** * Create a circle centered on (x, y) with a given radius */ public Circle ( double x , double y , double r ) { this . x = x ; this . y = y ; this . r = r ; this . id = Circle . lastId ; Circle . lastId += 1 ; } /** * Return how many circles have ever existed. */ public static int getNumOfCircles () { return Circle . lastId ; } } On Line 5, we added a new instance field id to store the identifier of the circle. Note that, since the identifier of a circle should not change once it is created, we use the keyword final here. On Line 6, we added a new class field lastId to remember that the lastId of the latest circle instance. This field is maintained as part of the class Circle and is initialized to 0. On Line 15 and 16, as part of the constructor, we initialize id to lastId and increment lastId . We explicitly access lastId through Circle to make it clear that lastId is a class field. Note that all of the above are done privately beneath the abstraction barrier. Since lastId is incremented by one every time a circle is created, we can also interpret lastId as the number of circles created so far. On Line 22-24, we added a method getNumOfCircles to return its value. The interesting thing here is that we declare getNumOfCircles with a static keyword. Similar to a static field, a static method is associated with a class, not to an instance of the class. Such method is called a class method . A class method is always invoked without being attached to an instance, and so it cannot access its instance fields or call other of its instance methods. The reference this has no meaning within a class method. Furthermore, just like a class field, a class method should be accessed through the class. For example, Circle . getNumOfCircles () . Other examples of class methods include the methods provided in java.lang.Math : sqrt , min , etc. These methods can be invoked through the Math class: e.g., Math.sqrt(x) . The main method The most common class method you will use is probably the main method. Every Java program has a class method called main , which serves as the entry point to the program. To run a Java program, we need to tell the JVM the class whose main method should be invoked first. In the example that we have seen, 1 java Hello will invoke the main method defined within the class Hello to kick start the execution of the program. The main method must be defined in the following way: 1 2 public final static void main ( String args [] ) { } You have learned what public and static means. The return type void indicates that main must not return a value. We have discussed what final means on a field, but are not ready to explain what final means on a method yet. main takes in an array ( [] ) of strings as parameters. These are the command-line arguments that we can pass in when invoking java . String (or java.lang.String ) is another class provided by the Java library that encapsulates a sequence of characters.","title":"8. Class Methods"},{"location":"08-static-method.html#unit-8-class-methods","text":"After this unit, students should: understand the differences between instance methods and class methods be able to define and use a class method know that the main method is the entry point to a Java program the modifies and parameters required for a main method Let's suppose that, in our program, we wish to assign a unique integer identifier to every Circle object ever created. We can do this with the additions below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Circle { private double x ; // x-coordinate of the center private double y ; // y-coordinate of the center private double r ; // the length of the radius private final int id ; // identifier private static int lastId = 0 ; // the id of the latest circle instance /** * Create a circle centered on (x, y) with a given radius */ public Circle ( double x , double y , double r ) { this . x = x ; this . y = y ; this . r = r ; this . id = Circle . lastId ; Circle . lastId += 1 ; } /** * Return how many circles have ever existed. */ public static int getNumOfCircles () { return Circle . lastId ; } } On Line 5, we added a new instance field id to store the identifier of the circle. Note that, since the identifier of a circle should not change once it is created, we use the keyword final here. On Line 6, we added a new class field lastId to remember that the lastId of the latest circle instance. This field is maintained as part of the class Circle and is initialized to 0. On Line 15 and 16, as part of the constructor, we initialize id to lastId and increment lastId . We explicitly access lastId through Circle to make it clear that lastId is a class field. Note that all of the above are done privately beneath the abstraction barrier. Since lastId is incremented by one every time a circle is created, we can also interpret lastId as the number of circles created so far. On Line 22-24, we added a method getNumOfCircles to return its value. The interesting thing here is that we declare getNumOfCircles with a static keyword. Similar to a static field, a static method is associated with a class, not to an instance of the class. Such method is called a class method . A class method is always invoked without being attached to an instance, and so it cannot access its instance fields or call other of its instance methods. The reference this has no meaning within a class method. Furthermore, just like a class field, a class method should be accessed through the class. For example, Circle . getNumOfCircles () . Other examples of class methods include the methods provided in java.lang.Math : sqrt , min , etc. These methods can be invoked through the Math class: e.g., Math.sqrt(x) .","title":"Unit 8: Class Methods"},{"location":"08-static-method.html#the-main-method","text":"The most common class method you will use is probably the main method. Every Java program has a class method called main , which serves as the entry point to the program. To run a Java program, we need to tell the JVM the class whose main method should be invoked first. In the example that we have seen, 1 java Hello will invoke the main method defined within the class Hello to kick start the execution of the program. The main method must be defined in the following way: 1 2 public final static void main ( String args [] ) { } You have learned what public and static means. The return type void indicates that main must not return a value. We have discussed what final means on a field, but are not ready to explain what final means on a method yet. main takes in an array ( [] ) of strings as parameters. These are the command-line arguments that we can pass in when invoking java . String (or java.lang.String ) is another class provided by the Java library that encapsulates a sequence of characters.","title":"The main method"},{"location":"09-composition.html","text":"Unit 9: Composition After learning this unit, students should understand: how to compose a new class from existing classes using composition how composition models the HAS-A relationship how sharing reference values in composed objects could lead to surprising results Adding more Abstractions Our previous implementation of Circle stores the center using its Cartesian coordinate \\((x,y)\\) . We have a method contains that takes in the Cartesian coordinate of a point. As such, our implementation of Circle assumes that a 2D point is best represented using its Cartesian coordinate. Recall that we wish to hide the implementation details as much as possible, protecting them with an abstraction barrier, so that the client does not have to bother about the details and it is easy for the implementer to change the details. In this example, what happens if the application finds that it is more convenient to use the polar coordinate to represent a 2D point? We will have to change the code of the constructor to Circle and the method contains . If our code contains other shapes or other methods in Circle that similarly assume a point is represented with its Cartesian coordinate, we will have to change them as well. It is easy for bugs to creep in. For instance, we might pass in the polar coordinate \\((r, \\theta)\\) to a method, but the method treats the two parameters as the Cartesian \\((x,y)\\) . We can apply the principle of abstraction and encapsulation here, and create a new class Point . The details of which are omitted and left as an exercise. With the Point class, our Circle class looks like the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // version 0.5 import java.lang.Math ; /** * A Circle object encapsulates a circle on a 2D plane. */ class Circle { private Point c ; // the center private double r ; // the length of the radius /** * Create a circle centered on Point c with given radius r */ public Circle ( Point c , double r ) { this . c = c ; this . r = r ; } /** * Return the area of the circle. */ public double getArea () { return Math . PI * this . r * this . r ; } /** * Return true if the given point p is within the circle. */ public boolean contains ( Point p ) { return false ; // TODO: Left as an exercise } } This example also illustrates the concept of composition . Our class Circle has been upgraded from being a bundle of primitive types and its methods, to a bundle that includes a reference type Point as well. In OOP, composition is a basic technique to build up layers of abstractions and construct sophisticated classes. We have mentioned that classes model real-world entities in OOP. The composition models that HAS-A relationship between two entities. For instance, a circle has a point as the center. Example: Cylinder Now let's build up another layer of abstraction and construct a 3D object -- a cylinder. A cylinder has a circle as its base and has a height value. Using composition, we can construct a Cylinder class: 1 2 3 4 5 6 7 8 9 10 class Cylinder { private Circle base ; private double height ; public Cylinder ( Circle base , double height ) { this . base = base ; this . height = height ; } // : } Sharing References Recall that unlike primitive types, reference types may share the same reference values. Let's look at the subtleties of how this could affect our code and catch us by surprise. Consider the following, where we create two circles c1 and c2 centered at the origin (0, 0). 1 2 3 Point p = new Point ( 0 , 0 ); Circle c1 = new Circle ( p , 1 ); Circle c2 = new Circle ( p , 4 ); Let's say that we want to allow a Circle to move its center. For the sake of this example, let's allow mutators on the class Point . Suppose we want to move c1 and only c1 to be centered at (1,1). 1 p . moveTo ( 1 , 1 ); You will find that by moving p , we are actually moving the center of both c1 and c2 ! This result is due to both circles c1 and c2 sharing the same point. When we pass the center into the constructor, we are passing the reference instead of passing a cloned copy of the center. This is a common source of bugs and we will see how we can reduce the possibilities of such bugs later in this module, but let's first consider the following \"fix\" (that is still not ideal). Let's suppose that instead of moving p , we add a moveTo method to the Circle instead: 1 2 3 4 5 6 7 8 9 10 11 12 13 class Circle { private Point c ; // the center private double r ; // the length of the radius : /** * move the center of this circle to the given point */ void moveTo ( Point c ) { this . c = c ; } : } Now, to move c1 , 1 2 3 4 Point p = new Point ( 0 , 0 ); Circle c1 = new Circle ( p , 1 ); Circle c2 = new Circle ( p , 4 ); c1 . moveTo ( new Point ( 1 , 1 )); You will find that c1 will now have a new center, but c2 's center remains at (0,0). Why doesn't this solve our problem then? Recall that we can further composed circles into other objects. Let's say that we have two cylinders: 1 2 Cylinder cylinder1 = new Cylinder(c1, 1); Cylinder cylinder2 = new Cylinder(c1, 1); that share the same base, then the same problem repeats itself! One solution is to avoid sharing references as much as possible. For instance, 1 2 3 4 5 6 7 Point p1 = new Point ( 0 , 0 ); Circle c1 = new Circle ( p1 , 1 ); Point p2 = new Point ( 0 , 0 ); Circle c2 = new Circle ( p2 , 4 ); p1 . moveTo ( 1 , 1 ); Without sharing references, moving p1 only affects c1 , so we are safe. The drawback of not sharing objects with the same content is that we will have a proliferation of objects and the computational resource usage is not optimized. This is an example of the trade offs we mentioned in the introduction to this module : we are scrificing the computational cost to save programmers from potential suffering! Another approach to address this issue is immutability . We will cover this later in the module.","title":"9. Composition"},{"location":"09-composition.html#unit-9-composition","text":"After learning this unit, students should understand: how to compose a new class from existing classes using composition how composition models the HAS-A relationship how sharing reference values in composed objects could lead to surprising results","title":"Unit 9: Composition"},{"location":"09-composition.html#adding-more-abstractions","text":"Our previous implementation of Circle stores the center using its Cartesian coordinate \\((x,y)\\) . We have a method contains that takes in the Cartesian coordinate of a point. As such, our implementation of Circle assumes that a 2D point is best represented using its Cartesian coordinate. Recall that we wish to hide the implementation details as much as possible, protecting them with an abstraction barrier, so that the client does not have to bother about the details and it is easy for the implementer to change the details. In this example, what happens if the application finds that it is more convenient to use the polar coordinate to represent a 2D point? We will have to change the code of the constructor to Circle and the method contains . If our code contains other shapes or other methods in Circle that similarly assume a point is represented with its Cartesian coordinate, we will have to change them as well. It is easy for bugs to creep in. For instance, we might pass in the polar coordinate \\((r, \\theta)\\) to a method, but the method treats the two parameters as the Cartesian \\((x,y)\\) . We can apply the principle of abstraction and encapsulation here, and create a new class Point . The details of which are omitted and left as an exercise. With the Point class, our Circle class looks like the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // version 0.5 import java.lang.Math ; /** * A Circle object encapsulates a circle on a 2D plane. */ class Circle { private Point c ; // the center private double r ; // the length of the radius /** * Create a circle centered on Point c with given radius r */ public Circle ( Point c , double r ) { this . c = c ; this . r = r ; } /** * Return the area of the circle. */ public double getArea () { return Math . PI * this . r * this . r ; } /** * Return true if the given point p is within the circle. */ public boolean contains ( Point p ) { return false ; // TODO: Left as an exercise } } This example also illustrates the concept of composition . Our class Circle has been upgraded from being a bundle of primitive types and its methods, to a bundle that includes a reference type Point as well. In OOP, composition is a basic technique to build up layers of abstractions and construct sophisticated classes. We have mentioned that classes model real-world entities in OOP. The composition models that HAS-A relationship between two entities. For instance, a circle has a point as the center.","title":"Adding more Abstractions"},{"location":"09-composition.html#example-cylinder","text":"Now let's build up another layer of abstraction and construct a 3D object -- a cylinder. A cylinder has a circle as its base and has a height value. Using composition, we can construct a Cylinder class: 1 2 3 4 5 6 7 8 9 10 class Cylinder { private Circle base ; private double height ; public Cylinder ( Circle base , double height ) { this . base = base ; this . height = height ; } // : }","title":"Example: Cylinder"},{"location":"09-composition.html#sharing-references","text":"Recall that unlike primitive types, reference types may share the same reference values. Let's look at the subtleties of how this could affect our code and catch us by surprise. Consider the following, where we create two circles c1 and c2 centered at the origin (0, 0). 1 2 3 Point p = new Point ( 0 , 0 ); Circle c1 = new Circle ( p , 1 ); Circle c2 = new Circle ( p , 4 ); Let's say that we want to allow a Circle to move its center. For the sake of this example, let's allow mutators on the class Point . Suppose we want to move c1 and only c1 to be centered at (1,1). 1 p . moveTo ( 1 , 1 ); You will find that by moving p , we are actually moving the center of both c1 and c2 ! This result is due to both circles c1 and c2 sharing the same point. When we pass the center into the constructor, we are passing the reference instead of passing a cloned copy of the center. This is a common source of bugs and we will see how we can reduce the possibilities of such bugs later in this module, but let's first consider the following \"fix\" (that is still not ideal). Let's suppose that instead of moving p , we add a moveTo method to the Circle instead: 1 2 3 4 5 6 7 8 9 10 11 12 13 class Circle { private Point c ; // the center private double r ; // the length of the radius : /** * move the center of this circle to the given point */ void moveTo ( Point c ) { this . c = c ; } : } Now, to move c1 , 1 2 3 4 Point p = new Point ( 0 , 0 ); Circle c1 = new Circle ( p , 1 ); Circle c2 = new Circle ( p , 4 ); c1 . moveTo ( new Point ( 1 , 1 )); You will find that c1 will now have a new center, but c2 's center remains at (0,0). Why doesn't this solve our problem then? Recall that we can further composed circles into other objects. Let's say that we have two cylinders: 1 2 Cylinder cylinder1 = new Cylinder(c1, 1); Cylinder cylinder2 = new Cylinder(c1, 1); that share the same base, then the same problem repeats itself! One solution is to avoid sharing references as much as possible. For instance, 1 2 3 4 5 6 7 Point p1 = new Point ( 0 , 0 ); Circle c1 = new Circle ( p1 , 1 ); Point p2 = new Point ( 0 , 0 ); Circle c2 = new Circle ( p2 , 4 ); p1 . moveTo ( 1 , 1 ); Without sharing references, moving p1 only affects c1 , so we are safe. The drawback of not sharing objects with the same content is that we will have a proliferation of objects and the computational resource usage is not optimized. This is an example of the trade offs we mentioned in the introduction to this module : we are scrificing the computational cost to save programmers from potential suffering! Another approach to address this issue is immutability . We will cover this later in the module.","title":"Sharing References"},{"location":"10-inheritance.html","text":"Unit 10: Inheritance After taking this unit, students should: understand inheritance as a mechanism to extend existing code understand how inheritance models the IS-A relationship know how to use the extends keyword for inheritance understand inheritance as a subtype be able to determine the run-time type and compile-time type of a variable Extension with Composition We have seen how composition allows us to compose a new, more complex, class, out of existing classes, without breaking the abstraction barrier of existing classes. Sometimes, however, composition is not the right approach. Let's consider the following example. Let's suppose that we, as a client, want to add color as a property to our Circle . Without penetrating the abstraction barrier of Circle , we can do the following: 1 2 3 4 5 6 7 8 9 10 // version 0.1 (using composition) class ColoredCircle { private Circle circle ; private Color color ; public ColoredCircle ( Circle circle , Color color ) { this . circle = circle ; this . color = color ; } } where Color is another abstraction representing the color of shapes. What should we do if we want to calculate the area of our colored circle? Suppose we already have a ColoredCircle instance called coloredCircle . We could make circle public and call coloredCircle . circle . getArea () , or we could add an accessor and call coloredCircle . getCircle (). getArea () . Both of these are not ideal, since it breaks the abstraction barrier and reveals that the ColoredCircle class stores a circle (the latter being slightly better than the first). A better alternative is to let ColoredCircle provide its own getArea() method, and forward its call to Circle . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // version 0.2 (using composition) class ColoredCircle { private Circle circle ; private Color color ; public ColoredCircle ( Circle circle , Color color ) { this . circle = circle ; this . color = color ; } public double getArea () { return circle . getArea (); } } Then, the client to ColoredCircle can just call coloredCircle . getArea () without knowing or needing to know how a colored circle is represented internally. The drawback of this approach is that we might end up with many boilerplate forwarding methods. Extension with Inheritance Recall the concept of subtyping. We say that \\(S <: T\\) if any piece of code written for type \\(T\\) also works for type \\(S\\) . Now, think about ColoredCircle and Circle . If someone has written a piece of code that operates on Circle objects. Do we expect the same code to work on ColoredCircle ? In this example, yes! A ColoredCircle object should behave just like a circle -- we can calculate its area, circumference, check if two circles intersect, check if a point falls within the circle, etc. The only difference, or more precisely, extension, is that it has a color, and perhaps has some methods related to this additional field. So, ColoredCircle is a subtype of Circle . We now show you how we can introduce this subtype relationship in Java, using the extends keyword. We can reimplement our ColoredCircle class this way: 1 2 3 4 5 6 7 8 9 // version 0.3 (using inheritance) class ColoredCircle extends Circle { private Color color ; public ColoredCircle ( Point center , double radius , Color color ) { super ( center , radius ); // call the parent's constructor this . color = color ; } } We just created a new type ColoredCircle as a class that extends from Circle . We call Circle the parent class or superclass of ColoredCircle ; and ColoredCircle a subclass of Circle . We also say that ColoredCircle inherits from Circle , since all the public fields of Circle (center and radius) and public methods (like getArea() ) are now accessible to ColoredCircle . Just like a parent-child relationship in real-life, however, anything private to the parent remains inaccessible to the child. This privacy veil maintains the abstraction barrier of the parent from the child, and creates a bit of a tricky situation -- technically a child ColoredCircle object has a center and a radius, but it has no access to it! Line 6 of the code above introduces another keyword in Java: super . Here, we use super to call the constructor of the superclass, to initialize its center and radius (since the child has no direct access to these fields that it inherited). The concept we have shown you is called inheritance and is one of the four pillars of OOP. We can think of inheritance as a model for the \" is a \" relationship between two entities. With inheritance, we can call coloredCircle . getArea () without knowing or needing to know how a colored circle is represented internally and without forwarding methods. When NOT to Use Inheritance Inheritance tends to get overused. In practice, we seldom use inheritance . Let's look at some examples of how not to use inheritance, and why. You may come across examples online or in books that look like the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Point { private double x ; private double y ; : } class Circle extends Point { private double radius ; : } class Cylinder extends Circle { private double height ; : } The difference between these implementations and the one you have seen in Unit 9 is that it uses inheritance rather than composition. Circle implemented like the above would have the center coordinate inherited from the parent (so it has three fields, x, y, and radius); Cylinder would have the fields corresponding to a circle, which is its base and height. In terms of modeling the properties of circle and cylinder, we have all the right properties in the right class. When we start to consider methods encapsulated with each object, things start to break down. Consider a piece of code written as follows: 1 2 3 4 5 void foo ( Circle c , Point p ) { if ( c . contains ( p )) { // do something } } Since Cylinder is a subtype of Point according to the implementation above, the code above should still work also if we replace Point with a Cylinder (according to the semantic of subtyping). But it gets weird -- what is the meaning of a Circle (in 2D) contain a Cylinder (in 3D)? We could come up with a convoluted meaning that explains this, but it is likely not what the original implementer of foo expects. The message here is this: Use composition to model has-a relationship; inheritance for is-a relationship . Make sure inheritance preserves the meaning of subtyping . Run-Time Type Recall that Java allows a variable of type \\(T\\) to hold a value from a variable of type \\(S\\) only if \\(S <: T\\) . Since ColoredCircle <: Circle , the following is not allowed in Java: 1 ColoredCircle c = new Circle(p, 0); // error but this is OK: 1 Circle c = new ColoredCircle(p, 0, blue); // OK where p is a Point object and blue is a Color object. Also, recall that Circle is called the compile-time type of c . Here, we see that c is now referencing an object of subtype ColoredCircle . Since this assignment happens during run-time, we say that the run-time type of c is ColoredCircle . The distinction between these two types will be important later.","title":"10. Inheritance"},{"location":"10-inheritance.html#unit-10-inheritance","text":"After taking this unit, students should: understand inheritance as a mechanism to extend existing code understand how inheritance models the IS-A relationship know how to use the extends keyword for inheritance understand inheritance as a subtype be able to determine the run-time type and compile-time type of a variable","title":"Unit 10: Inheritance"},{"location":"10-inheritance.html#extension-with-composition","text":"We have seen how composition allows us to compose a new, more complex, class, out of existing classes, without breaking the abstraction barrier of existing classes. Sometimes, however, composition is not the right approach. Let's consider the following example. Let's suppose that we, as a client, want to add color as a property to our Circle . Without penetrating the abstraction barrier of Circle , we can do the following: 1 2 3 4 5 6 7 8 9 10 // version 0.1 (using composition) class ColoredCircle { private Circle circle ; private Color color ; public ColoredCircle ( Circle circle , Color color ) { this . circle = circle ; this . color = color ; } } where Color is another abstraction representing the color of shapes. What should we do if we want to calculate the area of our colored circle? Suppose we already have a ColoredCircle instance called coloredCircle . We could make circle public and call coloredCircle . circle . getArea () , or we could add an accessor and call coloredCircle . getCircle (). getArea () . Both of these are not ideal, since it breaks the abstraction barrier and reveals that the ColoredCircle class stores a circle (the latter being slightly better than the first). A better alternative is to let ColoredCircle provide its own getArea() method, and forward its call to Circle . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // version 0.2 (using composition) class ColoredCircle { private Circle circle ; private Color color ; public ColoredCircle ( Circle circle , Color color ) { this . circle = circle ; this . color = color ; } public double getArea () { return circle . getArea (); } } Then, the client to ColoredCircle can just call coloredCircle . getArea () without knowing or needing to know how a colored circle is represented internally. The drawback of this approach is that we might end up with many boilerplate forwarding methods.","title":"Extension with Composition"},{"location":"10-inheritance.html#extension-with-inheritance","text":"Recall the concept of subtyping. We say that \\(S <: T\\) if any piece of code written for type \\(T\\) also works for type \\(S\\) . Now, think about ColoredCircle and Circle . If someone has written a piece of code that operates on Circle objects. Do we expect the same code to work on ColoredCircle ? In this example, yes! A ColoredCircle object should behave just like a circle -- we can calculate its area, circumference, check if two circles intersect, check if a point falls within the circle, etc. The only difference, or more precisely, extension, is that it has a color, and perhaps has some methods related to this additional field. So, ColoredCircle is a subtype of Circle . We now show you how we can introduce this subtype relationship in Java, using the extends keyword. We can reimplement our ColoredCircle class this way: 1 2 3 4 5 6 7 8 9 // version 0.3 (using inheritance) class ColoredCircle extends Circle { private Color color ; public ColoredCircle ( Point center , double radius , Color color ) { super ( center , radius ); // call the parent's constructor this . color = color ; } } We just created a new type ColoredCircle as a class that extends from Circle . We call Circle the parent class or superclass of ColoredCircle ; and ColoredCircle a subclass of Circle . We also say that ColoredCircle inherits from Circle , since all the public fields of Circle (center and radius) and public methods (like getArea() ) are now accessible to ColoredCircle . Just like a parent-child relationship in real-life, however, anything private to the parent remains inaccessible to the child. This privacy veil maintains the abstraction barrier of the parent from the child, and creates a bit of a tricky situation -- technically a child ColoredCircle object has a center and a radius, but it has no access to it! Line 6 of the code above introduces another keyword in Java: super . Here, we use super to call the constructor of the superclass, to initialize its center and radius (since the child has no direct access to these fields that it inherited). The concept we have shown you is called inheritance and is one of the four pillars of OOP. We can think of inheritance as a model for the \" is a \" relationship between two entities. With inheritance, we can call coloredCircle . getArea () without knowing or needing to know how a colored circle is represented internally and without forwarding methods.","title":"Extension with Inheritance"},{"location":"10-inheritance.html#when-not-to-use-inheritance","text":"Inheritance tends to get overused. In practice, we seldom use inheritance . Let's look at some examples of how not to use inheritance, and why. You may come across examples online or in books that look like the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Point { private double x ; private double y ; : } class Circle extends Point { private double radius ; : } class Cylinder extends Circle { private double height ; : } The difference between these implementations and the one you have seen in Unit 9 is that it uses inheritance rather than composition. Circle implemented like the above would have the center coordinate inherited from the parent (so it has three fields, x, y, and radius); Cylinder would have the fields corresponding to a circle, which is its base and height. In terms of modeling the properties of circle and cylinder, we have all the right properties in the right class. When we start to consider methods encapsulated with each object, things start to break down. Consider a piece of code written as follows: 1 2 3 4 5 void foo ( Circle c , Point p ) { if ( c . contains ( p )) { // do something } } Since Cylinder is a subtype of Point according to the implementation above, the code above should still work also if we replace Point with a Cylinder (according to the semantic of subtyping). But it gets weird -- what is the meaning of a Circle (in 2D) contain a Cylinder (in 3D)? We could come up with a convoluted meaning that explains this, but it is likely not what the original implementer of foo expects. The message here is this: Use composition to model has-a relationship; inheritance for is-a relationship . Make sure inheritance preserves the meaning of subtyping .","title":"When NOT to Use Inheritance"},{"location":"10-inheritance.html#run-time-type","text":"Recall that Java allows a variable of type \\(T\\) to hold a value from a variable of type \\(S\\) only if \\(S <: T\\) . Since ColoredCircle <: Circle , the following is not allowed in Java: 1 ColoredCircle c = new Circle(p, 0); // error but this is OK: 1 Circle c = new ColoredCircle(p, 0, blue); // OK where p is a Point object and blue is a Color object. Also, recall that Circle is called the compile-time type of c . Here, we see that c is now referencing an object of subtype ColoredCircle . Since this assignment happens during run-time, we say that the run-time type of c is ColoredCircle . The distinction between these two types will be important later.","title":"Run-Time Type"},{"location":"11-overriding.html","text":"Unit 11: Overriding After reading this unit, students should be aware that every class inherits from Object be familiar with the equals and toString methods understand what constitutes a method signature understand method overriding appreciate the power of method overriding understand what Java annotations are for, and know when to use @Override be exposed to the String class and its associated methods, especially the + operator Object and String In Java, every class that does not extend another class inherits from the class Object implicitly. Object is, therefore, the \"ancestors\" of all classes in Java and is at the root of the class hierarchy. The Object class does not encapsulate anything in particular. It is a very general class that provides useful methods common to all objects. The two useful ones that we are going to spend time with are: equals(Object obj) , which checks if two objects are equal to each other, and toString() , which returns a string representation of the object as a String object. The toString Method The toString method is very special, as this is invoked implicitly by Java, by default, to convert a reference object to a String object during string concatenation using the operator + . We showed you that in Python, 4 + \"Hello\" would result in a type mismatch error. In Java, however, 4 + \"Hello\" will result in the string \"4Hello\" . In this example, the primitive value 4 is converted to a string before concatenation. A more interesting scenario is what happens if we try to concatenate, say, a Circle object with a string. Let's say we have: 1 2 Circle c = new Circle ( new Point ( 0 , 0 ), 4.0 ); String s = \"Circle c is \" + c ; You will see that s now contains the string \"Circle c is Circle@1ce92674 (the seemingly gibberish after @` is the reference to the object and so your result will be different). What happened here is that the + operator sees that one of the operands is a string but the other is not, so it converts the one that is not a string to a string by calling its toString() method automatically for us. This is equivalent to 1 1 2 Circle c = new Circle ( new Point ( 0 , 0 ), 4.0 ); String s = \"Circle c is \" + c . toString (); Recall that in our Circle class (up to version 0.5) we do not have any toString method. The toString method that we invoked here is the toString method inherited from its parent Object . jshell and toString Recall that jshell is a REPL tool. After evaluating an expression, jshell prints the resulting value out. If the resulting value is a reference type, jshell will invoke toString to convert the reference type to a string first, before printing the string. Customizing toString for Circle The Object::toString method (that is our notation for the method toString from the class Object ) is not very user friendly. Ideally, when we print a Circle object, say, for debugging, we want to see its center and its radius. To do so, we can define our own toString method in Circle . Let's upgrade our Circle class to do this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // version 0.6 import java.lang.Math ; /** * A Circle object encapsulates a circle on a 2D plane. */ class Circle { private Point c ; // the center private double r ; // the length of the radius /** * Create a circle centered on Point c with given radius r */ public Circle ( Point c , double r ) { this . c = c ; this . r = r ; } /** * Return the area of the circle. */ public double getArea () { return Math . PI * this . r * this . r ; } /** * Return true if the given point p is within the circle. */ public boolean contains ( Point p ) { return false ; // TODO: Left as an exercise } /** * Return the string representation of this circle. */ @Override public String toString () { return \"{ center: \" + this . c + \", radius:\" + this . r + \" }\" ; } } The body of the method toString simply constructs a string representation for this circle object and returns. With this toString implemented, the output will look something like this: 1 Circle c is { center: (0.0, 0.0), radius: 4.0 } Note that when the center this.c is converted to a string, the toString method of Point is invoked. We leave the implementation of Point::toString as an exercise. Method Overriding What we just did is called method overriding in OOP. Inheritance is not only good for extending the behavior of an existing class but through method overriding, we can alter the behavior of an existing class as well. Let's define the method signature of a method as the method name and the number, type, and order of its parameters, and the method descriptor as the method signature plus the return type. When a subclass defines an instance method with the same method descriptor as an instance method in the parent class, we say that the instance method in the subclass overrides the instance method in the parent class 2 . In the example above, Circle::toString has overridden Object::toString . The @Override Annotation Line 37 in the example above contains the symbol @Override . This symbol is an example of annotation in Java. An annotation is not part of the program and does not affect the bytecode generated. Instead, it is a hint to the compiler. Remember that the compiler is our friend who will do its best to help detect errors early, during compilation. We must do our part to help the compiler help us. Here, @Override is a hint to the compiler that the following method, toString , is intended to override the method in the parent class. In case, there is a typo and overriding is not possible, the compiler will let us know. It is therefore recommended and expected that all overriding methods in your code are annotated with @Override . Using super To Access Overridden Methods After a subclass overrides a method in the superclass, the methods that have been overridden can still be called, with the super keyword. For instance, the following Circle::toString calls Object::toString to prefix the string representation of the circle with Circle@1ce92674 . 1 2 3 4 @Override public String toString () { return super . toString () + \" { center: \" + this . c + \", radius:\" + this . r + \" }\" ; } Calling toString explicit is not wrong, but we usually omit the call to keep the code readable and succinct. \u21a9 It is possible to override a method in some cases when the return type is different. We will discuss this during recitations. \u21a9","title":"11. Overriding"},{"location":"11-overriding.html#unit-11-overriding","text":"After reading this unit, students should be aware that every class inherits from Object be familiar with the equals and toString methods understand what constitutes a method signature understand method overriding appreciate the power of method overriding understand what Java annotations are for, and know when to use @Override be exposed to the String class and its associated methods, especially the + operator","title":"Unit 11: Overriding"},{"location":"11-overriding.html#object-and-string","text":"In Java, every class that does not extend another class inherits from the class Object implicitly. Object is, therefore, the \"ancestors\" of all classes in Java and is at the root of the class hierarchy. The Object class does not encapsulate anything in particular. It is a very general class that provides useful methods common to all objects. The two useful ones that we are going to spend time with are: equals(Object obj) , which checks if two objects are equal to each other, and toString() , which returns a string representation of the object as a String object.","title":"Object and String"},{"location":"11-overriding.html#the-tostring-method","text":"The toString method is very special, as this is invoked implicitly by Java, by default, to convert a reference object to a String object during string concatenation using the operator + . We showed you that in Python, 4 + \"Hello\" would result in a type mismatch error. In Java, however, 4 + \"Hello\" will result in the string \"4Hello\" . In this example, the primitive value 4 is converted to a string before concatenation. A more interesting scenario is what happens if we try to concatenate, say, a Circle object with a string. Let's say we have: 1 2 Circle c = new Circle ( new Point ( 0 , 0 ), 4.0 ); String s = \"Circle c is \" + c ; You will see that s now contains the string \"Circle c is Circle@1ce92674 (the seemingly gibberish after @` is the reference to the object and so your result will be different). What happened here is that the + operator sees that one of the operands is a string but the other is not, so it converts the one that is not a string to a string by calling its toString() method automatically for us. This is equivalent to 1 1 2 Circle c = new Circle ( new Point ( 0 , 0 ), 4.0 ); String s = \"Circle c is \" + c . toString (); Recall that in our Circle class (up to version 0.5) we do not have any toString method. The toString method that we invoked here is the toString method inherited from its parent Object . jshell and toString Recall that jshell is a REPL tool. After evaluating an expression, jshell prints the resulting value out. If the resulting value is a reference type, jshell will invoke toString to convert the reference type to a string first, before printing the string.","title":"The toString Method"},{"location":"11-overriding.html#customizing-tostring-for-circle","text":"The Object::toString method (that is our notation for the method toString from the class Object ) is not very user friendly. Ideally, when we print a Circle object, say, for debugging, we want to see its center and its radius. To do so, we can define our own toString method in Circle . Let's upgrade our Circle class to do this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // version 0.6 import java.lang.Math ; /** * A Circle object encapsulates a circle on a 2D plane. */ class Circle { private Point c ; // the center private double r ; // the length of the radius /** * Create a circle centered on Point c with given radius r */ public Circle ( Point c , double r ) { this . c = c ; this . r = r ; } /** * Return the area of the circle. */ public double getArea () { return Math . PI * this . r * this . r ; } /** * Return true if the given point p is within the circle. */ public boolean contains ( Point p ) { return false ; // TODO: Left as an exercise } /** * Return the string representation of this circle. */ @Override public String toString () { return \"{ center: \" + this . c + \", radius:\" + this . r + \" }\" ; } } The body of the method toString simply constructs a string representation for this circle object and returns. With this toString implemented, the output will look something like this: 1 Circle c is { center: (0.0, 0.0), radius: 4.0 } Note that when the center this.c is converted to a string, the toString method of Point is invoked. We leave the implementation of Point::toString as an exercise.","title":"Customizing toString for Circle"},{"location":"11-overriding.html#method-overriding","text":"What we just did is called method overriding in OOP. Inheritance is not only good for extending the behavior of an existing class but through method overriding, we can alter the behavior of an existing class as well. Let's define the method signature of a method as the method name and the number, type, and order of its parameters, and the method descriptor as the method signature plus the return type. When a subclass defines an instance method with the same method descriptor as an instance method in the parent class, we say that the instance method in the subclass overrides the instance method in the parent class 2 . In the example above, Circle::toString has overridden Object::toString .","title":"Method Overriding"},{"location":"11-overriding.html#the-override-annotation","text":"Line 37 in the example above contains the symbol @Override . This symbol is an example of annotation in Java. An annotation is not part of the program and does not affect the bytecode generated. Instead, it is a hint to the compiler. Remember that the compiler is our friend who will do its best to help detect errors early, during compilation. We must do our part to help the compiler help us. Here, @Override is a hint to the compiler that the following method, toString , is intended to override the method in the parent class. In case, there is a typo and overriding is not possible, the compiler will let us know. It is therefore recommended and expected that all overriding methods in your code are annotated with @Override . Using super To Access Overridden Methods After a subclass overrides a method in the superclass, the methods that have been overridden can still be called, with the super keyword. For instance, the following Circle::toString calls Object::toString to prefix the string representation of the circle with Circle@1ce92674 . 1 2 3 4 @Override public String toString () { return super . toString () + \" { center: \" + this . c + \", radius:\" + this . r + \" }\" ; } Calling toString explicit is not wrong, but we usually omit the call to keep the code readable and succinct. \u21a9 It is possible to override a method in some cases when the return type is different. We will discuss this during recitations. \u21a9","title":"The @Override Annotation"},{"location":"12-polymorphism.html","text":"Unit 12: Polymorphism After reading this unit, students should understand dynamic binding and polymorphism be aware of the equals method and the need to override it to customize the equality test understand when narrowing type conversion and type casting are allowed Taking on Many Forms Method overriding enables polymorphism , the fourth and the last pillar of OOP, and arguably the most powerful one. It allows us to change how existing code behaves, without changing a single of the existing code (or even have access to the code). Consider the function say below: 1 2 3 void say ( Object obj ) { System . out . println ( \"Hi, I am \" + obj . toString ()); } Note that this method receives an Object instance. Since both Point <: Object and Circle <: Object , we can do the following: 1 2 3 4 Point p = new Point(0, 0); say(p); Circle c = new Circle(p, 4); say(c); When executed, say will first print Hi, I am (0.0, 0.0) , followed by Hi, I am { center: (0.0, 0.0), radius: 4.0 } . We are invoking the overriding Point::toString in the first call, and Circle::toString in the second call . The same method invocation obj.toString() causes two different methods to be called in two separate invocations! In biology, polymorphism means that an organism can have many different forms. Here, the variable obj can have many forms as well. Which method is invoked is decided during run-time , depending on the run-time type of the obj . This is called dynamic binding or late binding or dynamic dispatch . Before we get into this in more detail, let consider overriding Object::equals . The equals method Object::equals compares if two object references refer to the same object. Suppose we have: 1 2 3 Circle c0 = new Circle ( new Point ( 0 , 0 ), 10 ); Circle c1 = new Circle ( new Point ( 0 , 0 ), 10 ); Circle c2 = c1 ; c2.equals(c1) returns true , but c0.equals(c1) returns false . Even though c0 and c1 are semantically the same, they refer to the two different objects. To compare if two circles are semantically the same, we need to override this method 2 . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // version 0.7 import java.lang.Math ; /** * A Circle object encapsulates a circle on a 2D plane. */ class Circle { private Point c ; // the center private double r ; // the length of the radius /** * Create a circle centered on Point c with given radius r */ public Circle ( Point c , double r ) { this . c = c ; this . r = r ; } /** * Return the area of the circle. */ public double getArea () { return Math . PI * this . r * this . r ; } /** * Return true if the given point p is within the circle. */ public boolean contains ( Point p ) { return false ; // TODO: Left as an exercise } /** * Return the string representation of this circle. */ @Override public String toString () { return \"{ center: \" + this . c + \", radius:\" + this . r + \" }\" ; } /** * Return true the object is the same circle (i.e., same center, same radius). */ @Override public boolean equals ( Object obj ) { if ( obj instanceof Circle ) { Circle circle = ( Circle ) obj ; return ( circle . c . equals ( this . c ) && circle . r == this . r ); } return false ; } } This is more complicated than toString . There are a few new concepts involved here: equals takes in a parameter of compile-time type Object . It only makes sense if we compare (during run-time) a circle with another circle. So, we first check if the run-time type of obj is a subtype of Circle . This is done using the instanceof operator. The operator returns true if obj has a run-time type that is a subtype of Circle . To compare this circle with the given circle, we have to access the center c and radius r . But if we access obj.c or obj.r , the compiler will complain. As far as the compiler is concerned, obj has the compile-time type Object , and there is no such fields c and r in the class Object ! This is why, after assuring that the run-time type of obj is a subtype of Circle , we assign obj to another variable circle that has the compile-time type Circle . We finally check if the two centers are equal (again, Point::equals is left as an exercise) and the two radii are equal 1 . The statement that assigns obj to circle involve type casting . We mentioned before that Java is strongly typed and so it is very strict about type conversion. Here, Java allows type casting from type \\(T\\) to \\(S\\) if \\(S <: T\\) . This is called narrowing type conversion . Unlike widening type conversion, which is always allowed and always correct, a narrowing type conversion requires explicit typecasting and validation during run-time. If we do not ensure that obj has the correct run-time type, casting can lead to a run-time error (which if you recall , is bad). All these complications would go away, however, if we define Circle::equals to take in a Circle as a parameter, like this: 1 2 3 4 5 6 7 8 9 10 class Circle { : /** * Return true the object is the same circle (i.e., same center, same radius). */ @Override public boolean equals(Circle circle) { return (circle.c.equals(this.c) && circle.r == this.r); } } This version of equals however, does not override Object::equals . Since we hinted to the compiler that we meant this to be an overriding method, using @Override , the compiler will give us an error. This is not treated as method overriding, since the signature for Circle::equals is different from Object::equals . Why then is overriding important? Why not just leave out the line @Override and live with the non-overriding, one-line, equals method above? The Power of Polymorphism Let's consider the following example. Suppose we have a general contains method that takes in an array of objects. The array can store any types of objects: Circle , Square , Rectangle , Point , String , etc. The method contains also takes in a target obj to search for, and returns true if there is an object in array that equals to obj . 1 2 3 4 5 6 7 8 9 // version 0.1 (with polymorphism) boolean contains ( Object array [] , Object obj ) { for ( Object curr : array ) { if ( curr . equals ( obj )) { return true ; } } return false ; } With overriding and polymorphism, the magic happens in Line 4 -- depending on the run-time type of curr , the corresponding, customized version of equals is called to compare against obj . However, if Circle::equals takes in a Circle as the parameter, the call to equals inside the method contains would not invoke Circle::equals . It would invoke Object::equals instead due to the matching method signature, and we can't search for Circle based on semantic equality. To have a generic contains method without polymorphism and overriding, we will have to do something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // version 0.2 (without polymorphism) boolean contains ( Object array [] , Object obj ) { for ( Object curr : array ) { if ( obj instanceof Circle ) { if ( array . equals (( Circle ) obj )) { return true ; } } else if ( obj instanceof Square ) { if ( array . equals (( Square ) obj )) { return true ; } } else if ( obj instanceof Point ) { if ( array . equals (( Point ) obj )) { return true ; } } : } return false ; } which is not scalable since every time we add a new class, we have to come back to this method and add a new branch to the if-else statement! As this example has shown, polymorphism allows us to write succinct code that is future proof . By dynamically deciding which method implementation to execute during run-time, the implementer can write short yet very general code that works for existing classes as well as new classes that might be added in the future by the client, without even the need to re-compile! The right way to compare two floating-point numbers is to take their absolute difference and check if the difference is small enough. We are sloppy here to keep the already complicated code a bit simpler. You shouldn't do this in your code. \u21a9 If we override equals() , we should generally override hashCode() as well, but let's leave that for another lesson on another day. \u21a9","title":"12. Polymorphism"},{"location":"12-polymorphism.html#unit-12-polymorphism","text":"After reading this unit, students should understand dynamic binding and polymorphism be aware of the equals method and the need to override it to customize the equality test understand when narrowing type conversion and type casting are allowed","title":"Unit 12: Polymorphism"},{"location":"12-polymorphism.html#taking-on-many-forms","text":"Method overriding enables polymorphism , the fourth and the last pillar of OOP, and arguably the most powerful one. It allows us to change how existing code behaves, without changing a single of the existing code (or even have access to the code). Consider the function say below: 1 2 3 void say ( Object obj ) { System . out . println ( \"Hi, I am \" + obj . toString ()); } Note that this method receives an Object instance. Since both Point <: Object and Circle <: Object , we can do the following: 1 2 3 4 Point p = new Point(0, 0); say(p); Circle c = new Circle(p, 4); say(c); When executed, say will first print Hi, I am (0.0, 0.0) , followed by Hi, I am { center: (0.0, 0.0), radius: 4.0 } . We are invoking the overriding Point::toString in the first call, and Circle::toString in the second call . The same method invocation obj.toString() causes two different methods to be called in two separate invocations! In biology, polymorphism means that an organism can have many different forms. Here, the variable obj can have many forms as well. Which method is invoked is decided during run-time , depending on the run-time type of the obj . This is called dynamic binding or late binding or dynamic dispatch . Before we get into this in more detail, let consider overriding Object::equals .","title":"Taking on Many Forms"},{"location":"12-polymorphism.html#the-equals-method","text":"Object::equals compares if two object references refer to the same object. Suppose we have: 1 2 3 Circle c0 = new Circle ( new Point ( 0 , 0 ), 10 ); Circle c1 = new Circle ( new Point ( 0 , 0 ), 10 ); Circle c2 = c1 ; c2.equals(c1) returns true , but c0.equals(c1) returns false . Even though c0 and c1 are semantically the same, they refer to the two different objects. To compare if two circles are semantically the same, we need to override this method 2 . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // version 0.7 import java.lang.Math ; /** * A Circle object encapsulates a circle on a 2D plane. */ class Circle { private Point c ; // the center private double r ; // the length of the radius /** * Create a circle centered on Point c with given radius r */ public Circle ( Point c , double r ) { this . c = c ; this . r = r ; } /** * Return the area of the circle. */ public double getArea () { return Math . PI * this . r * this . r ; } /** * Return true if the given point p is within the circle. */ public boolean contains ( Point p ) { return false ; // TODO: Left as an exercise } /** * Return the string representation of this circle. */ @Override public String toString () { return \"{ center: \" + this . c + \", radius:\" + this . r + \" }\" ; } /** * Return true the object is the same circle (i.e., same center, same radius). */ @Override public boolean equals ( Object obj ) { if ( obj instanceof Circle ) { Circle circle = ( Circle ) obj ; return ( circle . c . equals ( this . c ) && circle . r == this . r ); } return false ; } } This is more complicated than toString . There are a few new concepts involved here: equals takes in a parameter of compile-time type Object . It only makes sense if we compare (during run-time) a circle with another circle. So, we first check if the run-time type of obj is a subtype of Circle . This is done using the instanceof operator. The operator returns true if obj has a run-time type that is a subtype of Circle . To compare this circle with the given circle, we have to access the center c and radius r . But if we access obj.c or obj.r , the compiler will complain. As far as the compiler is concerned, obj has the compile-time type Object , and there is no such fields c and r in the class Object ! This is why, after assuring that the run-time type of obj is a subtype of Circle , we assign obj to another variable circle that has the compile-time type Circle . We finally check if the two centers are equal (again, Point::equals is left as an exercise) and the two radii are equal 1 . The statement that assigns obj to circle involve type casting . We mentioned before that Java is strongly typed and so it is very strict about type conversion. Here, Java allows type casting from type \\(T\\) to \\(S\\) if \\(S <: T\\) . This is called narrowing type conversion . Unlike widening type conversion, which is always allowed and always correct, a narrowing type conversion requires explicit typecasting and validation during run-time. If we do not ensure that obj has the correct run-time type, casting can lead to a run-time error (which if you recall , is bad). All these complications would go away, however, if we define Circle::equals to take in a Circle as a parameter, like this: 1 2 3 4 5 6 7 8 9 10 class Circle { : /** * Return true the object is the same circle (i.e., same center, same radius). */ @Override public boolean equals(Circle circle) { return (circle.c.equals(this.c) && circle.r == this.r); } } This version of equals however, does not override Object::equals . Since we hinted to the compiler that we meant this to be an overriding method, using @Override , the compiler will give us an error. This is not treated as method overriding, since the signature for Circle::equals is different from Object::equals . Why then is overriding important? Why not just leave out the line @Override and live with the non-overriding, one-line, equals method above?","title":"The equals method"},{"location":"12-polymorphism.html#the-power-of-polymorphism","text":"Let's consider the following example. Suppose we have a general contains method that takes in an array of objects. The array can store any types of objects: Circle , Square , Rectangle , Point , String , etc. The method contains also takes in a target obj to search for, and returns true if there is an object in array that equals to obj . 1 2 3 4 5 6 7 8 9 // version 0.1 (with polymorphism) boolean contains ( Object array [] , Object obj ) { for ( Object curr : array ) { if ( curr . equals ( obj )) { return true ; } } return false ; } With overriding and polymorphism, the magic happens in Line 4 -- depending on the run-time type of curr , the corresponding, customized version of equals is called to compare against obj . However, if Circle::equals takes in a Circle as the parameter, the call to equals inside the method contains would not invoke Circle::equals . It would invoke Object::equals instead due to the matching method signature, and we can't search for Circle based on semantic equality. To have a generic contains method without polymorphism and overriding, we will have to do something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // version 0.2 (without polymorphism) boolean contains ( Object array [] , Object obj ) { for ( Object curr : array ) { if ( obj instanceof Circle ) { if ( array . equals (( Circle ) obj )) { return true ; } } else if ( obj instanceof Square ) { if ( array . equals (( Square ) obj )) { return true ; } } else if ( obj instanceof Point ) { if ( array . equals (( Point ) obj )) { return true ; } } : } return false ; } which is not scalable since every time we add a new class, we have to come back to this method and add a new branch to the if-else statement! As this example has shown, polymorphism allows us to write succinct code that is future proof . By dynamically deciding which method implementation to execute during run-time, the implementer can write short yet very general code that works for existing classes as well as new classes that might be added in the future by the client, without even the need to re-compile! The right way to compare two floating-point numbers is to take their absolute difference and check if the difference is small enough. We are sloppy here to keep the already complicated code a bit simpler. You shouldn't do this in your code. \u21a9 If we override equals() , we should generally override hashCode() as well, but let's leave that for another lesson on another day. \u21a9","title":"The Power of Polymorphism"},{"location":"environments.html","text":"The CS2030S Programming Environment Java version Java is a language that continues to evolve. A new version is released every six months, and by the time we are done with CS2030S this semester, we will have Java 16. For CS2030S, we will only use Java 11, the most recent version with long-term support. Programming Servers The school has provided a list of computing servers for you to use. You can access them remotely via ssh , or secure shell. The hosts are named pe111 , pe112 , ... , pe120 . ( pe stands for \"programming environment\"). We will refer to these servers generally as the PE hosts. For this semester, the two servers pe115 and pe116 are not available. You can choose which of the eight hosts to use. You share the same home directory across all the hosts (this home directory, however, is different from that of sunfire ). If you notice that one host is crowded, you can use another host to spread out the load. While you can complete the programming assignments on your computers, the practical exams are done in a controlled environment using servers similar to the PE hosts. It is therefore advisable for you to familiarize yourself with accessing the PE servers via ssh and edit your program with either vim or emacs ( vim is recommended and supported). Basic Requirements You need to have an SoC Unix account. If you do not have one, you can apply for one online . Once you have an account, you need to activate your access to the PE hosts , which is part of the SoC computer clusters. You need a command-line ssh client. Windows 10, macOS, and Linux users should already have it installed by default. For older versions of Windows, such as those used in the SoC's programming labs, you can check out XShell 6 (free for home/school use), or PuTTY . These are GUI-based programs so the command line instructions below do not apply. Basic Command to SSH Run: 1 ssh <username>@<hostname> Replace <hostname> with the host you want to log into and <username> with your SoC Unix username. Note that both are case sensitive. For instance, I would do: 1 ssh ooiwt@sunfire.comp.nus.edu.sg to log into sunfire . After the command above, following the instructions on the screen. The first time you ever connect to a host, you will be warned that you are connecting to a previously unknown host. Say yes , and you will be prompted with your password for that host. Accessing The PE Hosts from Outside SoC The PE hosts can only be accessed from within the School of Computing networks. To complete the lab at home and to complete the two practical assessments from home, you need to access the PE hosts from outside the SoC networks. There are several ways to do this, the simplest way is to tunnel through sunfire , and this is the recommended method, as no extra software is required. Option 1: Tunneling through Sunfire (Recommended for those in Singapore) SoC's Sunfire ( sunfire.comp.nus.edu.sg ) is configured to allow your connection if it's originating from a local telco (See more details here ). Since sunfire is within the SoC network, you can log into sunfire first, then from sunfire , log into one of the PE nodes from sunfire . These two steps can be done with one command: 1 ssh -t <username1>@sunfire.comp.nus.edu.sg ssh <username2>@pe1xx.comp.nus.edu.sg Note that in non-exam scenarios, username1 and username2 are both your SoC Unix username. You will be prompted for password twice. The first prompt will be for your password to sunfire , and the second, to pe1xx . For practical exams, you will be issued a special exam account to log into the PE hosts. In this case, username1 will be your SoC Unix username and username2 will be your special exam account. Students not in Singapore will need to access sunfire via SoC VPN. In which case, Option 2 would be better. Option 2: Using SoC VPN (Recommended only for not in Singapore) To set up the SOC Virtual Private Network (VPN), see instruction here ). The staff at helpdesk@comp.nus.edu.sg or the IT helpdesk in COM1, Level 1, will be able to help with you setting up if needed. SoC VPN vs NUS VPN Note that SoC VPN is different from NUS VPN. Connecting to NUS VPN only allows you access to the NUS internal network, but not the SoC internal network. Windows 10 Users: FortiClient from Windows Store Students have reported that running FortiClient downloaded from the Windows Store does not allow one to ssh from WSL to sunfire as expected. Therefore, Windows 10 users should download and install FortiClient VPN directly from FortiClient's website . Once you are connected to SoC VPN, you can run 1 ssh <username>@pe1xx.comp.nus.edu.sg Setting up SSH Keys Once you are comfortable with Unix, you can set up a pair of public/private keys for authentication. You can use 1 ssh-keygen -t rsa to generate a pair of keys on your local computer. Keep the private key id_rsa on your local machine in the hidden ~/.ssh directory, and copy the public key id_rsa.pub to your home directory on the remote host you want to log into. On this remote host, run 1 cat id_rsa.pub >> ~/.ssh/authorized_keys Make sure that the permission for .ssh both on the local machine and on the remote host are set to 700 and the files id_rsa on the local machine and authorized_keys on the remote host are set to 600 . Once set up, you need not enter your password every time you run ssh or scp . Troubleshooting If you get the following error: ssh: Could not resolve hostname pe1xx.comp.nus.edu.sg ssh cannot recognize the name pe1xx , likely, you are not tunneling connected to the SoC VPN. Connection closed by 192.168.48.xxx port 22 You have connected to the PE host, but you are kicked out because you have no permission to use the host. Make sure you have activated your access to \"SoC computer clusters\" here Permission denied, please try again You did not enter the correct password or username. Please use the username and password of your SoC Unix account which you have created here: https://mysoc.nus.edu.sg/~newacct/ . Check that you have entered your username correctly. It is case sensitive . If you have lost your password, go here: https://mysoc.nus.edu.sg/~myacct/iforgot.cgi ssh: connect to host sunfire.comp.nus.edu.sg port 22: Operation timed out It means that you failed to connect to sunfire via ssh . There could be two reasons for this: (i) sunfire or its ssh service is down; (ii) you are connecting via a network where sunfire is not accessible (such as outside Singapore). The likelihood of (i) is small. The more likely scenario is (ii), in which case, you should be able to solve it by connecting to SoC VPN. Could not chdir to home directory /home/o/ooiwt: Permission denied This error means that you have successfully connected to the PE hosts, but you have no access to your home directory. This should not happen. Please send an email with the above error message to helpdesk@comp.nus.edu.sg , include the PE hosts that you connected to with this error and your username. The system administrator can reset the permission of your home directory for you.","title":"Programming Environments"},{"location":"environments.html#the-cs2030s-programming-environment","text":"","title":"The CS2030S Programming Environment"},{"location":"environments.html#java-version","text":"Java is a language that continues to evolve. A new version is released every six months, and by the time we are done with CS2030S this semester, we will have Java 16. For CS2030S, we will only use Java 11, the most recent version with long-term support.","title":"Java version"},{"location":"environments.html#programming-servers","text":"The school has provided a list of computing servers for you to use. You can access them remotely via ssh , or secure shell. The hosts are named pe111 , pe112 , ... , pe120 . ( pe stands for \"programming environment\"). We will refer to these servers generally as the PE hosts. For this semester, the two servers pe115 and pe116 are not available. You can choose which of the eight hosts to use. You share the same home directory across all the hosts (this home directory, however, is different from that of sunfire ). If you notice that one host is crowded, you can use another host to spread out the load. While you can complete the programming assignments on your computers, the practical exams are done in a controlled environment using servers similar to the PE hosts. It is therefore advisable for you to familiarize yourself with accessing the PE servers via ssh and edit your program with either vim or emacs ( vim is recommended and supported).","title":"Programming Servers"},{"location":"environments.html#basic-requirements","text":"You need to have an SoC Unix account. If you do not have one, you can apply for one online . Once you have an account, you need to activate your access to the PE hosts , which is part of the SoC computer clusters. You need a command-line ssh client. Windows 10, macOS, and Linux users should already have it installed by default. For older versions of Windows, such as those used in the SoC's programming labs, you can check out XShell 6 (free for home/school use), or PuTTY . These are GUI-based programs so the command line instructions below do not apply.","title":"Basic Requirements"},{"location":"environments.html#basic-command-to-ssh","text":"Run: 1 ssh <username>@<hostname> Replace <hostname> with the host you want to log into and <username> with your SoC Unix username. Note that both are case sensitive. For instance, I would do: 1 ssh ooiwt@sunfire.comp.nus.edu.sg to log into sunfire . After the command above, following the instructions on the screen. The first time you ever connect to a host, you will be warned that you are connecting to a previously unknown host. Say yes , and you will be prompted with your password for that host.","title":"Basic Command to SSH"},{"location":"environments.html#accessing-the-pe-hosts-from-outside-soc","text":"The PE hosts can only be accessed from within the School of Computing networks. To complete the lab at home and to complete the two practical assessments from home, you need to access the PE hosts from outside the SoC networks. There are several ways to do this, the simplest way is to tunnel through sunfire , and this is the recommended method, as no extra software is required.","title":"Accessing The PE Hosts from Outside SoC"},{"location":"environments.html#option-1-tunneling-through-sunfire-recommended-for-those-in-singapore","text":"SoC's Sunfire ( sunfire.comp.nus.edu.sg ) is configured to allow your connection if it's originating from a local telco (See more details here ). Since sunfire is within the SoC network, you can log into sunfire first, then from sunfire , log into one of the PE nodes from sunfire . These two steps can be done with one command: 1 ssh -t <username1>@sunfire.comp.nus.edu.sg ssh <username2>@pe1xx.comp.nus.edu.sg Note that in non-exam scenarios, username1 and username2 are both your SoC Unix username. You will be prompted for password twice. The first prompt will be for your password to sunfire , and the second, to pe1xx . For practical exams, you will be issued a special exam account to log into the PE hosts. In this case, username1 will be your SoC Unix username and username2 will be your special exam account. Students not in Singapore will need to access sunfire via SoC VPN. In which case, Option 2 would be better.","title":"Option 1: Tunneling through Sunfire (Recommended for those in Singapore)"},{"location":"environments.html#option-2-using-soc-vpn-recommended-only-for-not-in-singapore","text":"To set up the SOC Virtual Private Network (VPN), see instruction here ). The staff at helpdesk@comp.nus.edu.sg or the IT helpdesk in COM1, Level 1, will be able to help with you setting up if needed. SoC VPN vs NUS VPN Note that SoC VPN is different from NUS VPN. Connecting to NUS VPN only allows you access to the NUS internal network, but not the SoC internal network. Windows 10 Users: FortiClient from Windows Store Students have reported that running FortiClient downloaded from the Windows Store does not allow one to ssh from WSL to sunfire as expected. Therefore, Windows 10 users should download and install FortiClient VPN directly from FortiClient's website . Once you are connected to SoC VPN, you can run 1 ssh <username>@pe1xx.comp.nus.edu.sg","title":"Option 2: Using SoC VPN (Recommended only for not in Singapore)"},{"location":"environments.html#setting-up-ssh-keys","text":"Once you are comfortable with Unix, you can set up a pair of public/private keys for authentication. You can use 1 ssh-keygen -t rsa to generate a pair of keys on your local computer. Keep the private key id_rsa on your local machine in the hidden ~/.ssh directory, and copy the public key id_rsa.pub to your home directory on the remote host you want to log into. On this remote host, run 1 cat id_rsa.pub >> ~/.ssh/authorized_keys Make sure that the permission for .ssh both on the local machine and on the remote host are set to 700 and the files id_rsa on the local machine and authorized_keys on the remote host are set to 600 . Once set up, you need not enter your password every time you run ssh or scp .","title":"Setting up SSH Keys"},{"location":"environments.html#troubleshooting","text":"If you get the following error: ssh: Could not resolve hostname pe1xx.comp.nus.edu.sg ssh cannot recognize the name pe1xx , likely, you are not tunneling connected to the SoC VPN. Connection closed by 192.168.48.xxx port 22 You have connected to the PE host, but you are kicked out because you have no permission to use the host. Make sure you have activated your access to \"SoC computer clusters\" here Permission denied, please try again You did not enter the correct password or username. Please use the username and password of your SoC Unix account which you have created here: https://mysoc.nus.edu.sg/~newacct/ . Check that you have entered your username correctly. It is case sensitive . If you have lost your password, go here: https://mysoc.nus.edu.sg/~myacct/iforgot.cgi ssh: connect to host sunfire.comp.nus.edu.sg port 22: Operation timed out It means that you failed to connect to sunfire via ssh . There could be two reasons for this: (i) sunfire or its ssh service is down; (ii) you are connecting via a network where sunfire is not accessible (such as outside Singapore). The likelihood of (i) is small. The more likely scenario is (ii), in which case, you should be able to solve it by connecting to SoC VPN. Could not chdir to home directory /home/o/ooiwt: Permission denied This error means that you have successfully connected to the PE hosts, but you have no access to your home directory. This should not happen. Please send an email with the above error message to helpdesk@comp.nus.edu.sg , include the PE hosts that you connected to with this error and your username. The system administrator can reset the permission of your home directory for you.","title":"Troubleshooting"},{"location":"unix-advanced.html","text":"Unix CLI: Advanced This article is adapted from the notes of the Unix@Home Workshop held in August 2020. After reading this article, students should appreciate the philosophy of Unix where small utitilies program can be composed together to perform a complex task using the pipe | operator be aware of basic Unix utilities: echo , sort , uniq , grep , head , and tail . be able to use basic pattern matching * ? [] and {} in bash know how to use Tab , Ctrl + P , and Ctrl + N to work more efficiently in bash know how to save time and effort by automating long complex commands using bash scripts Composing Programs with | Another key innovation of Unix is that led to its success is the invention of the | operator. Before Unix, operating systems tend to provide complex, monolithic, programs. The philosophy of Unix, however, is to provide many small, simple, utility programs, that can be composed to complete a more complex task. These small programs each do one thing only (and do it well) and so are easier to write and less prone to bugs. The composition of these utility programs relies on two things. First, plain text is often used as input and output of the programs. These allow the programs to understand each other easily. Second, they use | to communicate with each other. The | operator takes the standard output from one program and redirects it as the standard input of another program. For instance, 1 2 $ cat test.txt | wc 1 11 64 compose cat and wc together. Recall that cat reads the content of the file and prints it to standard output. Here, we pipe the standard output from cat to wc . So now, these printed texts are redirected as the standard input to wc . But this is just the same as 1 $ wc < test.txt that we have seen before. What's the power in | ? Now, recall that we have made copies of test.txt earlier, into foo.txt and bar.txt . If you have not done so or have removed them, you can quickly reproduce the files with: 1 2 $ cp test.txt foo.txt $ cp test.txt bar.txt Let's suppose now I want to count the total number of words for all three files. Instead of calling wc on each file one by one, and sum them up myself. I can just run: 1 2 $ cat test.txt foo.txt bar.txt | wc 3 33 192 Here, cat read the three files, concatenate their content, and pass the output to wc for counting. Useful Utilities Before we see more interesting examples of using | , let's move beyond cat and wc , and see what other simple tools are there in Unix. head and tail head and tail prints out the first \\(k\\) lines and last \\(k\\) lines from a file (or standard input if the file name is not given). By default, \\(k\\) is 10, but you can pass in an argument to specify \\(k\\) . 1 2 3 4 5 6 $ cat test.txt foo.txt bar.txt This is a test file for learning Unix file management commands. This is a test file for learning Unix file management commands. This is a test file for learning Unix file management commands. $ cat test.txt foo.txt bar.txt | tail -1 This is a test file for learning Unix file management commands. echo echo simply prints out the command-line argument to the standard output. 1 2 $ echo \"hello world!\" hello world! sort sort rearrange the input lines in alphabetical order. 1 2 3 4 5 6 7 8 9 $ sort john jane peter mary^D jane john mary peter In the example above, I entered john , jane , peter , mary followed by Ctrl + D to signify the end of input. sort prints out jane , john , mary , peter , in that order. uniq uniq remove any two consecutive lines that are the same. 1 2 3 4 5 6 7 8 9 10 $ uniq 1 2 2 2 1 1^D 1 2 1 For instance, in the above, there are three consecutive lines of 2 , so only one remained. There are also two consecutive lines of 1 , so only one remained.` grep grep returns the lines of text from the given file (or the standard input) that matches the given string. For instance, run 1 $ grep abc and start typing in some lines of text, some containing abc , some do not. grep will spew out into the standard output all the lines that contain the text abc somewhere. As usual, hit Ctrl + D when you are done. Pipe Example To give you an example of how useful | is, here is a real example. When processing the registration of the workshop, I have quite a few registrations that are duplicates -- students registered more than ones. I need a quick way to count how many unique registrants are there. So I keep the student id of all registrants in a file called ID . For instance, the file ID contains (not real data, of course) 1 2 3 4 5 6 7 8 9 A1234567X,CS A1234559A,CEG A1239999J,CEG A1234580K,CEG A1233210O,CS A1234567X,CS A1234581Q,ISC A1233216T,ISC A1239999J,CEG Now, to count how many unique registrants, I just need to run: 1 2 $ cat ID | sort | uniq | wc -l 7 To count how many uniq registrants are CEG students, I just change it to: 1 2 $ cat ID | sort | uniq | grep CEG | wc -l 3 Pattern Matching in bash We now show you another productivity shortcut. In an example earlier, you have seen how we passed in more than one file names into cat . Recall that we can use Tab to auto-complete the file names, so we can hit fewer keys on the keyboards. Now, we show you there is an even faster way. Instead of 1 $ cat test.txt foo.txt bar.txt | wc We could just run 1 $ cat *.txt | wc The * is a special character in bash that represents 0 or more characters. So, this command essentially says, cat any files that contain 0 or more characters, followed by .txt . The table below summarizes the useful patterns: Pattern Matches * 0 or more characters ? one character [..] one character, coming from the given set between [ and ] , - to indicate a range. {.., ..} Either one of the names, separated by , . Example 1: 1 2 $ ls ???.txt bar.txt foo.txt Since we use three ? , it matches any file name with three characters followed by .txt . Example 2: 1 2 $ ls [f-t]*t foo.txt test.txt The expression [f-t]*t matches all file names the start with alphabet f , g , etc, until t , followed by zero or more characters, followed by t . Example 3: 1 2 3 4 $ ls *.txt bar.txt foo.txt test.txt $ ls {fo,ba}??txt bar.txt foo.txt The expression {fo,ba}??txt matches any file names the start with either fo or ba , followed by two characters, followed by txt . Leveling Up Your Productivity with CLI Minimizing Hand Movements You have seen how you can manage files and navigate around the directory structure, all by interacting with the command-line interface. No windows. No mouse. Just you, the keyboard, and the terminal. You do not even need to use any arrow keys or function keys. Why is this a big deal? Let's look at the image of the keyboard below: We only need to use the keys colored in pink. And since these keys concentrated in a small region on the keyboard, for most of us, we can reach the keys if we just position our hands over the keyboard 1 , we only need move our fingers to type. Minimizing Typing We can even minimize the movement of our fingers in several ways by typing less. We have seen several ways where we have achieved these: Unix commands are named economically -- they are often only a few characters long. We can use Tab to auto-complete a command or a file name. We can use Ctrl + P or Ctrl + N to repeat a previous commands. There are many more bash shortcuts for productivity, if you are keen, take a look at (this cheat sheet]( https://github.com/fliptheweb/bash-shortcuts-cheat-sheet ). You have also seen that Unix has many small, simple, utilities that we can compose to solve a task. But composing them requires much typing: 1 $ cat ID | sort | uniq | grep CEG | wc -l If we need to run this over and over again or share this command with someone, we can simply put these commands in a file, and then run it by invoking its name. Such a file containing commands for the shell is called a shell script . For example, let's create a file named hello.sh containing the line echo hello! by: 1 2 $ cat > hello.sh echo hello!^D The extension .sh is not necessary but it is just something I use so that I can tell that this file contains a shell script. In the example above, cat will wait for me to enter something on the keyboard. So I entered echo hello! followed by Ctrl + D to indicate the end of the input. Now, to execute this file, we run: 1 2 $ bash hello.sh hello! or 1 2 $ bash < hello.sh hello! Recall that we said Unix shells do not necessarily interact with the users? This is an example. We pass the file hello.sh to a new instance of bash , asking it to interpret the lines inside this file as commands to execute. Remember that we want to minimize typing, so can we run it with less typing? What if we can just pass the filename directly to bash to execute? 1 2 $ ./hello.sh bash: ./hello.sh: Permission denied Here, we specify the relative path of the script hello.sh , including the prefix ./ (for reasons that we will explain later). But we should get an error telling us Permission defined . Recall from the File Permissions section that a file needs to have the executable x permission to be executed. So we need to add this permission for ourselves: 1 2 3 $ chmod u+x hello.sh $ ./hello.sh hello! The recommended placement of hands over the keyboard is so that the thumbs are over the Space bar, the left fingers are over A S D F , and the right fingers are over J K L ; . \u21a9","title":"Advanced"},{"location":"unix-advanced.html#unix-cli-advanced","text":"This article is adapted from the notes of the Unix@Home Workshop held in August 2020. After reading this article, students should appreciate the philosophy of Unix where small utitilies program can be composed together to perform a complex task using the pipe | operator be aware of basic Unix utilities: echo , sort , uniq , grep , head , and tail . be able to use basic pattern matching * ? [] and {} in bash know how to use Tab , Ctrl + P , and Ctrl + N to work more efficiently in bash know how to save time and effort by automating long complex commands using bash scripts","title":"Unix CLI: Advanced"},{"location":"unix-advanced.html#composing-programs-with","text":"Another key innovation of Unix is that led to its success is the invention of the | operator. Before Unix, operating systems tend to provide complex, monolithic, programs. The philosophy of Unix, however, is to provide many small, simple, utility programs, that can be composed to complete a more complex task. These small programs each do one thing only (and do it well) and so are easier to write and less prone to bugs. The composition of these utility programs relies on two things. First, plain text is often used as input and output of the programs. These allow the programs to understand each other easily. Second, they use | to communicate with each other. The | operator takes the standard output from one program and redirects it as the standard input of another program. For instance, 1 2 $ cat test.txt | wc 1 11 64 compose cat and wc together. Recall that cat reads the content of the file and prints it to standard output. Here, we pipe the standard output from cat to wc . So now, these printed texts are redirected as the standard input to wc . But this is just the same as 1 $ wc < test.txt that we have seen before. What's the power in | ? Now, recall that we have made copies of test.txt earlier, into foo.txt and bar.txt . If you have not done so or have removed them, you can quickly reproduce the files with: 1 2 $ cp test.txt foo.txt $ cp test.txt bar.txt Let's suppose now I want to count the total number of words for all three files. Instead of calling wc on each file one by one, and sum them up myself. I can just run: 1 2 $ cat test.txt foo.txt bar.txt | wc 3 33 192 Here, cat read the three files, concatenate their content, and pass the output to wc for counting.","title":"Composing Programs with |"},{"location":"unix-advanced.html#useful-utilities","text":"Before we see more interesting examples of using | , let's move beyond cat and wc , and see what other simple tools are there in Unix.","title":"Useful Utilities"},{"location":"unix-advanced.html#head-and-tail","text":"head and tail prints out the first \\(k\\) lines and last \\(k\\) lines from a file (or standard input if the file name is not given). By default, \\(k\\) is 10, but you can pass in an argument to specify \\(k\\) . 1 2 3 4 5 6 $ cat test.txt foo.txt bar.txt This is a test file for learning Unix file management commands. This is a test file for learning Unix file management commands. This is a test file for learning Unix file management commands. $ cat test.txt foo.txt bar.txt | tail -1 This is a test file for learning Unix file management commands.","title":"head and tail"},{"location":"unix-advanced.html#echo","text":"echo simply prints out the command-line argument to the standard output. 1 2 $ echo \"hello world!\" hello world!","title":"echo"},{"location":"unix-advanced.html#sort","text":"sort rearrange the input lines in alphabetical order. 1 2 3 4 5 6 7 8 9 $ sort john jane peter mary^D jane john mary peter In the example above, I entered john , jane , peter , mary followed by Ctrl + D to signify the end of input. sort prints out jane , john , mary , peter , in that order.","title":"sort"},{"location":"unix-advanced.html#uniq","text":"uniq remove any two consecutive lines that are the same. 1 2 3 4 5 6 7 8 9 10 $ uniq 1 2 2 2 1 1^D 1 2 1 For instance, in the above, there are three consecutive lines of 2 , so only one remained. There are also two consecutive lines of 1 , so only one remained.`","title":"uniq"},{"location":"unix-advanced.html#grep","text":"grep returns the lines of text from the given file (or the standard input) that matches the given string. For instance, run 1 $ grep abc and start typing in some lines of text, some containing abc , some do not. grep will spew out into the standard output all the lines that contain the text abc somewhere. As usual, hit Ctrl + D when you are done.","title":"grep"},{"location":"unix-advanced.html#pipe-example","text":"To give you an example of how useful | is, here is a real example. When processing the registration of the workshop, I have quite a few registrations that are duplicates -- students registered more than ones. I need a quick way to count how many unique registrants are there. So I keep the student id of all registrants in a file called ID . For instance, the file ID contains (not real data, of course) 1 2 3 4 5 6 7 8 9 A1234567X,CS A1234559A,CEG A1239999J,CEG A1234580K,CEG A1233210O,CS A1234567X,CS A1234581Q,ISC A1233216T,ISC A1239999J,CEG Now, to count how many unique registrants, I just need to run: 1 2 $ cat ID | sort | uniq | wc -l 7 To count how many uniq registrants are CEG students, I just change it to: 1 2 $ cat ID | sort | uniq | grep CEG | wc -l 3","title":"Pipe Example"},{"location":"unix-advanced.html#pattern-matching-in-bash","text":"We now show you another productivity shortcut. In an example earlier, you have seen how we passed in more than one file names into cat . Recall that we can use Tab to auto-complete the file names, so we can hit fewer keys on the keyboards. Now, we show you there is an even faster way. Instead of 1 $ cat test.txt foo.txt bar.txt | wc We could just run 1 $ cat *.txt | wc The * is a special character in bash that represents 0 or more characters. So, this command essentially says, cat any files that contain 0 or more characters, followed by .txt . The table below summarizes the useful patterns: Pattern Matches * 0 or more characters ? one character [..] one character, coming from the given set between [ and ] , - to indicate a range. {.., ..} Either one of the names, separated by , .","title":"Pattern Matching in bash"},{"location":"unix-advanced.html#example-1","text":"1 2 $ ls ???.txt bar.txt foo.txt Since we use three ? , it matches any file name with three characters followed by .txt .","title":"Example 1:"},{"location":"unix-advanced.html#example-2","text":"1 2 $ ls [f-t]*t foo.txt test.txt The expression [f-t]*t matches all file names the start with alphabet f , g , etc, until t , followed by zero or more characters, followed by t .","title":"Example 2:"},{"location":"unix-advanced.html#example-3","text":"1 2 3 4 $ ls *.txt bar.txt foo.txt test.txt $ ls {fo,ba}??txt bar.txt foo.txt The expression {fo,ba}??txt matches any file names the start with either fo or ba , followed by two characters, followed by txt .","title":"Example 3:"},{"location":"unix-advanced.html#leveling-up-your-productivity-with-cli","text":"","title":"Leveling Up Your Productivity with CLI"},{"location":"unix-advanced.html#minimizing-hand-movements","text":"You have seen how you can manage files and navigate around the directory structure, all by interacting with the command-line interface. No windows. No mouse. Just you, the keyboard, and the terminal. You do not even need to use any arrow keys or function keys. Why is this a big deal? Let's look at the image of the keyboard below: We only need to use the keys colored in pink. And since these keys concentrated in a small region on the keyboard, for most of us, we can reach the keys if we just position our hands over the keyboard 1 , we only need move our fingers to type.","title":"Minimizing Hand Movements"},{"location":"unix-advanced.html#minimizing-typing","text":"We can even minimize the movement of our fingers in several ways by typing less. We have seen several ways where we have achieved these: Unix commands are named economically -- they are often only a few characters long. We can use Tab to auto-complete a command or a file name. We can use Ctrl + P or Ctrl + N to repeat a previous commands. There are many more bash shortcuts for productivity, if you are keen, take a look at (this cheat sheet]( https://github.com/fliptheweb/bash-shortcuts-cheat-sheet ). You have also seen that Unix has many small, simple, utilities that we can compose to solve a task. But composing them requires much typing: 1 $ cat ID | sort | uniq | grep CEG | wc -l If we need to run this over and over again or share this command with someone, we can simply put these commands in a file, and then run it by invoking its name. Such a file containing commands for the shell is called a shell script . For example, let's create a file named hello.sh containing the line echo hello! by: 1 2 $ cat > hello.sh echo hello!^D The extension .sh is not necessary but it is just something I use so that I can tell that this file contains a shell script. In the example above, cat will wait for me to enter something on the keyboard. So I entered echo hello! followed by Ctrl + D to indicate the end of the input. Now, to execute this file, we run: 1 2 $ bash hello.sh hello! or 1 2 $ bash < hello.sh hello! Recall that we said Unix shells do not necessarily interact with the users? This is an example. We pass the file hello.sh to a new instance of bash , asking it to interpret the lines inside this file as commands to execute. Remember that we want to minimize typing, so can we run it with less typing? What if we can just pass the filename directly to bash to execute? 1 2 $ ./hello.sh bash: ./hello.sh: Permission denied Here, we specify the relative path of the script hello.sh , including the prefix ./ (for reasons that we will explain later). But we should get an error telling us Permission defined . Recall from the File Permissions section that a file needs to have the executable x permission to be executed. So we need to add this permission for ourselves: 1 2 3 $ chmod u+x hello.sh $ ./hello.sh hello! The recommended placement of hands over the keyboard is so that the thumbs are over the Space bar, the left fingers are over A S D F , and the right fingers are over J K L ; . \u21a9","title":"Minimizing Typing"},{"location":"unix-background.html","text":"Unix CLI: Background This article is a replication of the notes from the Unix@Home Workshop held in August 2020. After reading this article, students should understand the basic terms: CLI, terminal, shell, command prompt appreciate why CLI is more efficient aware of the commonly used terminal control sequences What is Command-Line Interfaces? The command-line interfaces, or just CLI for short, is an important interface that we, as computing professionals, interact with the computer for most of our day-to-day tasks. In contrast to graphical user interfaces where users use a mouse to click/drag on menus and windows to interact with a computer, the command-line interface uses keyboard and text. The users would type a command to instruct the computer to do something, and the computer would respond by displaying the reply to the user. CLI evolves from teletypes machines where users would interact with the computer through a typewriter-like machine (see Figure 2.2. of this article for an example). Users would type a command on the keyboard, and the typewriter would print out, line-by-line, the output on a piece of paper. This is the era before monitors and mice. Again, driven by the constraints and the necessity, CLI interfaces are designed to be simple and economical. The commands are short and fast to type; the responses are succinct. Figure: A teletype device (Model 33 ASR) to interact with a computer. Why CLI over GUI? Since CLI is designed to be economical, CLI is much more efficient and productive to use, in particular when we are interacting with a remote computer over the network -- sending text back and forth is much more efficient than sending graphical elements over the network. Each character takes up to two bytes, but each pixel alone takes up 3 bytes of data. Another reason why using CLI is faster and more productive is that user can keep their hands on the keyboard at all time and not needing to switch frequently between keyboard and mouse. While research has shown that GUI and mouse are great for casual users, for software developers that need to type on the keyboard most of the time, having to switch between keyboard and mouse is a productivity-killer. Further, CLI commands typically provides a host of options that is accessible directly (including of clicking through preference dialogues) from the command line, making these commands flexible and customizable. Finally, since these commands are just text, we can put together a sequence of commands easily as a script , to automate highly repetitive tasks. What is a Terminal? With the advances in Cathode-ray tube (CRT), the teletype machine is replaced with computer terminals in the late 1970s. Instead of printing the output on paper, the output from CLI is now printed on a monitor supporting 24x80 characters on screen in black and white (or green). Figure: The VT100 Computer Terminal. In modern days, operating systems still use similar underlying functionalities to read in keyboard inputs and print out text to show to the users, but instead of these clunky special purpose devices, the functionality of a terminal is replaced by programs called terminal emulator or virtual terminal . Examples include Terminal and iTerm2 on macOS; Windows Terminal on Microsoft; xterm and konsole on Ubuntu, etc. Many legacy control commands on these teletype machines remain in today's computing environment, such as the terminal control sequence. What is a Shell? The term CLI refers to a type of user interface. To realize this interface, Unix computing environments rely on another type of program called shell . A shell usually works closely with a terminal to get inputs from the users, interpret the meaning of the inputs, execute the tasks (perhaps through the invocation of other programs), and returned the output back to the user through the terminal. Note that a shell can run on its own without a terminal (it can read input from a file, and write the output to a file, for instance). There are many shells available, each with different bells and whistles to help improve our productivity. The most popular shell that comes as default on many Unix systems is bash , or Bourne Again Shell. This is the shell that we will use in this workshop and as default in the SoC Unix computing environment. Other popular shells are fish and Oh-my-zsh ( zsh ). Command Prompt A shell has a command prompt . It typically looks something like this, but will be different depending on the default configuration on your machine: 1 ooiwt@pe111:~$ The prompt is where you type in a command for the shell to interpret and execute. In bash , the command prompt can be customized to include information such as the username, hostname, time, current working directory, etc. It is customary to use the $ sign as the final character of the prompt. In our examples, we will just show $ to incidate the command prompt. Depending on the habit, sometimes you are asked to type in a command \"into the terminal\", \"into the shell\", or \"into bash\". They all mean the same thing: type in the command at the command prompt of the shell. Terminal Control Sequence On the old teletype machines, a user can send special commands to the teletype machines to control its operation. Many of these special commands still exists today, and can be triggered by with hitting a combination of Ctrl and another key (i.e., a control sequence). The following lists some of the most useful control sequences to know: Ctrl + D : signal the end of input to a program. This is also used to exit from a shell (by telling the shell that you have no more input to send and you are done with it). Ctrl + Z : suspend the current running program. This pauses the execution of the program (but not terminating it). In the bash shell, the most recently suspended program can resume executing in the background with the command bg or brought back to execution in the foreground again with the command fg . Ctrl + C : terminate the current running program. Ctrl + S : freeze the terminal. This is a legacy control command that pauses the output printing of a teletype machine. You shouldn't need to use this control sequence. Ctrl + Q : resume the terminal. This is a legacy control command that resume the printing of a teletype machine. You shouldn't need to use this control sequence, unless you accidentally hit Ctrl + S Ctrl + Z vs. Ctrl + C A common mistake for new students is to hit Ctrl + Z frequently if something goes wrong with their program -- this behavior leads to large number of suspended programs (which still occupy resources such as memory on the computer). The right sequence to use is Ctrl + C -- which terminates the program (and frees up the resources). Ctrl + S accidents Since Ctrl + S is used as the \"save\" shortcut in non-Unix environment, many students accidentally hit this control sequence, causing their terminal to freeze. Don't panic if this happens. Just hit Ctrl + Q and things will be back to normal. References The Art of Unix Usability: Command Line Interfaces , by Eric Steven Raymond","title":"Background"},{"location":"unix-background.html#unix-cli-background","text":"This article is a replication of the notes from the Unix@Home Workshop held in August 2020. After reading this article, students should understand the basic terms: CLI, terminal, shell, command prompt appreciate why CLI is more efficient aware of the commonly used terminal control sequences","title":"Unix CLI: Background"},{"location":"unix-background.html#what-is-command-line-interfaces","text":"The command-line interfaces, or just CLI for short, is an important interface that we, as computing professionals, interact with the computer for most of our day-to-day tasks. In contrast to graphical user interfaces where users use a mouse to click/drag on menus and windows to interact with a computer, the command-line interface uses keyboard and text. The users would type a command to instruct the computer to do something, and the computer would respond by displaying the reply to the user. CLI evolves from teletypes machines where users would interact with the computer through a typewriter-like machine (see Figure 2.2. of this article for an example). Users would type a command on the keyboard, and the typewriter would print out, line-by-line, the output on a piece of paper. This is the era before monitors and mice. Again, driven by the constraints and the necessity, CLI interfaces are designed to be simple and economical. The commands are short and fast to type; the responses are succinct. Figure: A teletype device (Model 33 ASR) to interact with a computer.","title":"What is Command-Line Interfaces?"},{"location":"unix-background.html#why-cli-over-gui","text":"Since CLI is designed to be economical, CLI is much more efficient and productive to use, in particular when we are interacting with a remote computer over the network -- sending text back and forth is much more efficient than sending graphical elements over the network. Each character takes up to two bytes, but each pixel alone takes up 3 bytes of data. Another reason why using CLI is faster and more productive is that user can keep their hands on the keyboard at all time and not needing to switch frequently between keyboard and mouse. While research has shown that GUI and mouse are great for casual users, for software developers that need to type on the keyboard most of the time, having to switch between keyboard and mouse is a productivity-killer. Further, CLI commands typically provides a host of options that is accessible directly (including of clicking through preference dialogues) from the command line, making these commands flexible and customizable. Finally, since these commands are just text, we can put together a sequence of commands easily as a script , to automate highly repetitive tasks.","title":"Why CLI over GUI?"},{"location":"unix-background.html#what-is-a-terminal","text":"With the advances in Cathode-ray tube (CRT), the teletype machine is replaced with computer terminals in the late 1970s. Instead of printing the output on paper, the output from CLI is now printed on a monitor supporting 24x80 characters on screen in black and white (or green). Figure: The VT100 Computer Terminal. In modern days, operating systems still use similar underlying functionalities to read in keyboard inputs and print out text to show to the users, but instead of these clunky special purpose devices, the functionality of a terminal is replaced by programs called terminal emulator or virtual terminal . Examples include Terminal and iTerm2 on macOS; Windows Terminal on Microsoft; xterm and konsole on Ubuntu, etc. Many legacy control commands on these teletype machines remain in today's computing environment, such as the terminal control sequence.","title":"What is a Terminal?"},{"location":"unix-background.html#what-is-a-shell","text":"The term CLI refers to a type of user interface. To realize this interface, Unix computing environments rely on another type of program called shell . A shell usually works closely with a terminal to get inputs from the users, interpret the meaning of the inputs, execute the tasks (perhaps through the invocation of other programs), and returned the output back to the user through the terminal. Note that a shell can run on its own without a terminal (it can read input from a file, and write the output to a file, for instance). There are many shells available, each with different bells and whistles to help improve our productivity. The most popular shell that comes as default on many Unix systems is bash , or Bourne Again Shell. This is the shell that we will use in this workshop and as default in the SoC Unix computing environment. Other popular shells are fish and Oh-my-zsh ( zsh ).","title":"What is a Shell?"},{"location":"unix-background.html#command-prompt","text":"A shell has a command prompt . It typically looks something like this, but will be different depending on the default configuration on your machine: 1 ooiwt@pe111:~$ The prompt is where you type in a command for the shell to interpret and execute. In bash , the command prompt can be customized to include information such as the username, hostname, time, current working directory, etc. It is customary to use the $ sign as the final character of the prompt. In our examples, we will just show $ to incidate the command prompt. Depending on the habit, sometimes you are asked to type in a command \"into the terminal\", \"into the shell\", or \"into bash\". They all mean the same thing: type in the command at the command prompt of the shell.","title":"Command Prompt"},{"location":"unix-background.html#terminal-control-sequence","text":"On the old teletype machines, a user can send special commands to the teletype machines to control its operation. Many of these special commands still exists today, and can be triggered by with hitting a combination of Ctrl and another key (i.e., a control sequence). The following lists some of the most useful control sequences to know: Ctrl + D : signal the end of input to a program. This is also used to exit from a shell (by telling the shell that you have no more input to send and you are done with it). Ctrl + Z : suspend the current running program. This pauses the execution of the program (but not terminating it). In the bash shell, the most recently suspended program can resume executing in the background with the command bg or brought back to execution in the foreground again with the command fg . Ctrl + C : terminate the current running program. Ctrl + S : freeze the terminal. This is a legacy control command that pauses the output printing of a teletype machine. You shouldn't need to use this control sequence. Ctrl + Q : resume the terminal. This is a legacy control command that resume the printing of a teletype machine. You shouldn't need to use this control sequence, unless you accidentally hit Ctrl + S Ctrl + Z vs. Ctrl + C A common mistake for new students is to hit Ctrl + Z frequently if something goes wrong with their program -- this behavior leads to large number of suspended programs (which still occupy resources such as memory on the computer). The right sequence to use is Ctrl + C -- which terminates the program (and frees up the resources). Ctrl + S accidents Since Ctrl + S is used as the \"save\" shortcut in non-Unix environment, many students accidentally hit this control sequence, causing their terminal to freeze. Don't panic if this happens. Just hit Ctrl + Q and things will be back to normal.","title":"Terminal Control Sequence"},{"location":"unix-background.html#references","text":"The Art of Unix Usability: Command Line Interfaces , by Eric Steven Raymond","title":"References"},{"location":"unix-essentials.html","text":"Unix CLI: The Essentials This article is adapted from the notes of the Unix@Home Workshop held in August 2020. It contains the essential knowledge that a CS2030S students need to survive using the PE nodes to do the labs (and to use a Unix CLI in general). After following this article, students should be able to: navigate comfortably in a Unix file system using shell commands cd , pwd , and ls use . , .. , ~ or / to form a relative or absolute path name to a file organize files in a Unix file system using shell commands mkdir , rmdir , mv , rm , and cp view the content of the file using cat , more or less manage the permission of a file using chmod perform standard input/output redirection with < and > Unix Directory Unix organizes files according to a directory structure. The following shows an example. This structure is also known as a directory tree . There are two important directories that you need to know. Root Directory The root directory is the directory at the top of the directory tree 1 . It is simply referred to as / , without any name. Under the root directory are many other systems directory, which a casual user does not normally need to (and have no permission to) modify. Home Directory Each user has his/her own home directory. The above figure shows where the home directory of the user ooiwt resides in the directory tree. The user ooiwt may create files or directories in his/her home directory, but not elsewhere unless permission is given. The home directory is referred to with the symbol ~ in bash . Sometimes we add the username behind ~ to indicate the home directory of the other user. E.g., ~bob means the home directory of a user named bob . Current Working Directory A user can navigate around the directory tree. The current working directory is the directory that the user is currently in. In contrast to the root and home directory, which are fixed 2 , the current working directory changes as the user moves around. Knowing the current working directory is important since this is the default location in the directory tree a command executes. As such, many systems by default display the current working directory as part of the bash command prompt. The current working directory is referred to with the symbol . in bash . Parent Directory The parent directory is directory one layer up from the current directory. The parent directory is referred to with the symbol .. in bash . To summarize, here are the short form representations: Symbol Meaning / the root directory ~ the home directory . the current working directory .. the parent directory Specifying a Path To specify a directory or a file in the Unix directory tree, we can use either the absolute path or the relative path . Absolute path The absolute path is constructed as follows, starting from the root of the directory structure, find a path (a sequence of directories) to the location that you want to specify, then concatenate the names of the directories together, separated by the forward-slash / . This is a similar notation used for Web site URLs so you should already be familiar with it. For instance, the path /home/o/ooiwt is the absolute path of the directory named ooiwt in the figure above. An absolute path is independent of the current working directory and always start with / or ~ Relative path The relative path is dependent on the current working directory. To refer to another location, start from the current directory, and find a path (a sequence of directories) to the location that you refer to. When we go up a tree, we use .. to represent the directory. For example, referring to the figure above, if we are in the directory /home/b , and we wish to refer to /home/o/ooiwt , we can use the relative path ../o/ooiwt . If we wish to refer to /home/b/bob , we can use the relative path bob . A relative path never starts with / . Directory-related Commands Now, let's take a look at some basic commands available in bash that deals with navigation and directories. pwd : Print Current Working directory pwd shows you which directory you are currently in. Type pwd into the command prompt, and it will print the absolute path to your current working directory. For instance, Suppose you are in /home/o/ooiwt , entering 1 pwd will give the output 1 /home/o/ooiwt ls : LiSt content of a directory The ls list the content in the current working directory. Rule of Silence Unix follows the economical rule of silence : programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program. So, if ls has nothing to list, it will list nothing (as opposed to, say, printing \"This is an empty directory.\") mkdir : MaKe a subDIRectory The mkdir command creates a subdirectory with the given name in the current directory. In the example below, we assume that we start with an empty directory. 1 2 3 4 5 6 $ ls $ mkdir workshop $ ls workshop $ ls -F workshop/ Here, we create a directory called workshop . Now, when we ls , you can see the directory listed. You may also use ls -F for more information ( -F is one of the many options / flags available for the ls command. To see a complete list of the options, refer to the man pages, i.e., man ls .) The slash / beside the filename tells you that the file is a directory. A normal file does not have a slash beside its name when \"ls -F\" is used. You may also use the ls -l command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification. Use Up Arrow for Command History bash maintains a history of your previously executed commands, and you may use the Ctrl + P (previous) and Ctrl + N (next) to go through it. Press the Ctrl + P until you find a previously executed command. You may then press Enter to execute it or edit the command before executing it. This is handy when you need to repeatedly execute a long bash command. cd : Change Directory To navigate in the directory tree, changing the current working directory from one to another, we use the cd command. 1 2 3 4 5 $ pwd /home/o/ooiwt $ cd workshop $ pwd /home/o/ooiwt/workshop Suppose our starting working directory is /home/o/ooiwt , after we cd into workshop , the current working directory becomes /home/o/ooiwt/workshop . Note that cd can take in either an absolute path or a relative path. The example above takes in a relative path as the argument. As mentioned in \" Unix CLI: Background \", it is common to include the current working directory into the shell's prompt. So, you may see your command prompt updated to include the new working directory. Entering cd alone (without argument) brings you back to your home directory. rmdir : ReMove a subDIRectory rmdir removes a subDIRectory in the current directory -- note that a directory must be empty before it can be removed. The command 1 $ rmdir workshop will remove the directory that you just created. File Management This note assumes that you are familiar with navigation with the Unix directory structure. We will now learn some commands to help us deal with files. Let's recreate the workshop directory in case you have already deleted it with the rmdir at the end of the last unit. 1 2 3 $ mkdir -p workshop $ cd workshop $ ls All of the above commands should complete successfully and silently . Let's populate the directory with a new file. Cut-and-paste the command below into the command prompt : 1 wget https://raw.githubusercontent.com/nus-unix-workshop/2021-s1/master/test.txt You should see a file being downloaded and saved with an output similar to below: 1 2 3 4 5 6 7 8 9 10 --2020-07-27 15:26:49-- https://raw.githubusercontent.com/nus-unix-workshop/2021-s1/master/test.txt Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 151.101.0.133, 151.101.64.133, 151.101.128.133, ... Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.0.133|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 64 [text/plain] Saving to: \u2018test.txt\u2019 test.txt 100%[======================>] 64 --.-KB/s in 0s 2020-07-27 15:26:50 (2.35 MB/s) - \u2018test.txt\u2019 saved [64/64] Now run ls , and you should see that ls returns test.txt as the content of the current working directory. 1 2 $ ls test.txt cp : CoPy files Now let's try to copy this file to another name. 1 2 3 $ cp test.txt foo.txt $ ls test.txt foo.txt The command above copies the file test.txt into foo.txt . If you want to copy the whole directory, use -r flag, where r stands for copying recursively. Now let's create another directory called copy . 1 2 3 4 $ cd .. $ mkdir copy $ cd copy $ ls Run pwd to double-check that you are in the directory called copy that is at the same level as workshop . Now, we are going to use cp with the -r flag, to copy recursively the whole of workshop directory over. 1 $ cp -r ../workshop . The command cp takes in two arguments, the first is the source, and the second is the destination. Note that we use . above to indicate that we wish to copy the whole sub-tree of workshop over the current directory. The command should complete without any message. Upon completion, you can run ls to double-check that the workshop directory exists under workshop . !!! Warning: cp Overwrites If there is an existing file with the same name, cp will overwrite the existing file without warning. mv : MoVe or rename files Now, let's change directory back to workshop . 1 $ cd ../workshop and use the mv command to rename foo.txt into bar.txt . 1 2 3 4 5 $ ls foo.txt test.txt $ mv foo.txt bar.txt $ ls bar.txt test.txt As you can see above, just like cp , mv takes in two arguments, the first is the source and the second is the destination. If the destination of mv is a directory, however, instead of renaming, the mv commands move the source to the destination directory. 1 2 3 4 5 $ ls bar.txt test.txt $ mv ../copy/workshop/foo.txt . $ ls bar.txt foo.txt test.txt Here, you can see that we have moved foo.txt over to the current directory. !!! Warning: mv Overwrites If there is an existing file with the same name, mv will overwrite the existing file without warning. mv comes with a -i flag that interactively asks you if you are sure if you want to overwrite a file. It is a good idea to always run mv -i . Hit Y to continue overwriting the existing file. You can look up on the Internet on how to make -i the default using alias command in .bashrc . Use Tab for Name Completion If you have a very long file name, you may use the bash auto-completion feature to reduce typing. For instance, you may type: 1 $ mv t and press the Tab key, bash will complete the filename for you if there is only one filename with the prefix \"t\". Otherwise, it will fill up the filename to the point where you need to type in more characters for disambiguation. The Tab key can also complete the name of a command. rm : ReMove files We can use rm to remove files. Be careful with this command -- files deleted cannot be restored. There is no trash or recycled bin like in Mac or Windows. 1 2 3 4 5 $ ls bar.txt foo.txt test.txt $ rm foo.txt $ ls bar.txt test.txt rm -rf While the Unix command line provides lots of flexibility and power, with great power comes great responsibility. Some of the commands are extremely dangerous. rm -rf * is the most famous one. The notation * refers to all files, and the flag -f means forceful deletion (no question asked!), and -r means remove recursively everything under the current directory tree. Accidentally running this command has ruined many lives. Read more here rm comes with a -i flag that interactively asks you if you are sure if you want to delete a file. It is a good idea to always run rm -i . 1 2 $ rm -i bar.txt rm: remove regular file 'bar.txt'? Type y or n to answer yes or no respectively. cat : CATenate file content to screen To quickly take a look at the content of the file, use the cat command. 1 2 $ cat test.txt This is a test file for learning Unix file management commands. less is a variant of cat that includes features to read each page leisurely and is useful for long files. 1 $ less test.txt In less , use <space> to move down one page, b to move Back up one page, and q to Quit. man : Online MANual An online help facility is available in Unix via the man command ( man stands for MANual). To look for more information about any Unix command, for example, ls , type man ls . Type man man and refer to Man Pages to find out more about the facility. To exit man , press q . File Permission Management File permissions determine who can do what to a file. Typically, you do not need to fiddle with the file permission, but when you need to, it is usually for an important reason and it is critical to do it right. The What of File Permissions Let's look at what you can do to a file first. Unix file permissions allow control of three actions: r (read), w (write) and x (execute). These permission settings allow the following different actions to be done for regular files and directories. permission effect on file effect on directory r reading the content of a file read the names of the files in the directory w writing into a file create/delete/rename files in the directory x executing a file access contents and meta-info (size, creation time) of files in the directory These three actions can be controlled independently. The permissions on a file can be expressed in two ways: using symbolic notation. For instance, rwx , r-x , -wx , where a - means that the corresponding permission is not given (in the order of r , w , x ). using a numerical notation. This notation uses a digit between 0 and 7, which is computed as a sum of the individual digit representing the permissions: r is represented with 4, w is represented with 2, and x is represented with 1. For instance, r-x has a numerical representation of 5, and -wx has a numerical representation of 3. The Who of File Permissions Unix divides the users into three classes: u is the u ser who owns the file; g refers to the users in the same g roup as the user; and o are all the o ther users. The permissions can be controlled separately for these classes of users. The permission notation simply concatenates the file permissions of each class of users together, in the order of u , g , and o . For instance, the permission of 644, or rw-r--r-- , on a file means that: the owner can read and write the group users can only read all the other users can only read Checking file permission You can view the permission of a file by using the ls -l command ( l for long format): 1 2 $ ls -l test.txt -rw-r--r--@ 1 ooiwt staff 64 Jul 28 09:52 test.txt Ignoring the first - and the last @ , you can see that the permission of test.txt is 644. The chmod command You can use chmod command to change the permissions of a file or a directory. For instance, 1 2 3 $ chmod 666 test.txt $ ls -l test.txt -rw-rw-rw-@ 1 ooiwt staff 64 Jul 28 09:52 test.txt would change add the permission w to both group and other users 1 . An alternative way is to just specify the changes. To remove the write permission from others, you can write: 1 2 3 $ chmod o-w test.txt $ ls -l test.txt -rw-rw-r--@ 1 ooiwt staff 64 Jul 28 09:52 test.txt Common Scenarios for chmod Here are some scenarios where you might need to use the chmod command: If you use the SoC Unix server to do your homework, you should prevent the directory that stores your homework from being accessible by other users. Make sure that your homework directory as the permission of 700 . If you download a file from the Internet and you do not have the permission to read it, you should do a u+r to give yourself the read permission. A program should have execution permission to run. If you have a script or an executable file that you can't run, give yourself the execution permission u+x . Standard Input/Output History Two of the design decisions of Unix that lead to its simplicity are the decisions to (i) decouple the physical input/output devices from the programs, allowing programs written for Unix to read from abstract input and output devices; and (ii) make all programs read and write from these abstract input and output devices by default. Before Unix, the older operating systems often require programmers to painstakingly set up connections to the teletype machines and other devices for reading inputs and printing outputs. With Unix, programmers can now focus on solving the tasks at hand and let Unix takes care of the input and output. The two abstract devices that Unix provides are called standard input and standard output . By default, the standard input refers to the keyboard and the standard output is the terminal . Examples using cat and wc Let's look at these concepts closer, by examining some examples. Remember cat ? The cat command takes in a filename and it prints the content of the file to the standard output. 1 2 $ cat test.txt This is a test file for learning Unix file management commands. If no filename is given, cat by default try to read from the standard input. Try running: 1 $ cat You will see that the command is waiting for you to type in something. Type in anything, as soon as you press Enter , cat is going to read in the text from the standard input, as if it is the content of a file, and then prints the content to the standard output. You can keep typing, supplying text to cat , or you can type Ctrl + D to send the end-of-input command to cat . Let's look at another command, wc . wc is a utility that counts the number of lines, words, characters. If we call wc and supply it a file name, it will count the number of lines, words, and characters in that given file. 1 2 $ wc test.txt 1 11 64 test.txt The output means that there is 1 line, 11 words, and 64 characters in the file test.txt . But if you do not pass in any file name, wc is going to read in the text from the standard input, as if it is the content of a file, and prints the three counters to the standard output. Go ahead and try: 1 $ wc You will see that the wc command is waiting for you to type in something. Type in a few sentences, you can hit Enter for a new line. When you are done, type Ctrl + D . wc will count the number of lines, words, and characters for the text that you just entered. Output Redirection By defining two abstract input and output devices (or channels), Unix frees the programmers from worrying about where to read the input from and write the output to. Most of the time, we can write the output of the program to the standard output. In instances where we need to write the output to another location, we can just redirect the output. The operators > and >> are used to redirect the standard output to a file. The difference is that > will overwrite the given file, while >> will concatenate into the given file. For example: 1 2 3 $ wc test.txt > test.count $ cat test.count 1 11 64 test.txt The first command redirects the output from wc to a file named test.count , so you do not see anything printed to the output anymore. We can check by running cat on the new file test.count -- indeed the original output from wc is now stored in the file test.count . If we repeat the command wc test.txt > test.count again, you can see that the file has been overwritten with the output from wc again. But if we replace > with >> , a new line is concatenated into test.count . So the file now has two lines. 1 2 3 4 5 6 7 $ wc test.txt > test.count $ cat test.count 1 11 64 test.txt $ wc test.txt >> test.count $ cat test.count 1 11 64 test.txt 1 11 64 test.txt Input Redirection The operator < is used to redirect a file into the standard input. So, instead of reading from the keyboard, we can now read from a file. Commands such as cat and wc already support from a file directly, so there is no difference in terms of functionality to run the commands by passing in the file name, or by using the < operator. 1 2 3 4 5 6 7 8 $ wc test.txt 1 11 64 test.txt $ wc < test.txt 1 11 64 $ cat test.txt This is a test file for learning Unix file management commands. $ cat < test.txt This is a test file for learning Unix file management commands. Note the slight difference in the output format of the second wc above -- it no longer prints the file name since from wc points of view, it is read from the standard input and not from a file, so it is not aware of the file named test.txt In most CS programming assignments, however, to keep things simple, you will be asked to read from the standard input only, so the < is a great time-saver -- you do not have to repeatedly type in the same input data over and over from the keyboard. You can just save the input data in a file, then redirect it to standard input with the < operator. Other Useful Online Tools explainshell explain each shell command for you Giving write permission to other users is a security risk and you should not do this unless you know what you are doing. \u21a9 \u21a9 Not exactly true -- since Unix is designed to be flexible, even the root and the home directory can be changed! But let's not worry about that for now since there is no good reason to do that as a beginner. \u21a9","title":"Essentials"},{"location":"unix-essentials.html#unix-cli-the-essentials","text":"This article is adapted from the notes of the Unix@Home Workshop held in August 2020. It contains the essential knowledge that a CS2030S students need to survive using the PE nodes to do the labs (and to use a Unix CLI in general). After following this article, students should be able to: navigate comfortably in a Unix file system using shell commands cd , pwd , and ls use . , .. , ~ or / to form a relative or absolute path name to a file organize files in a Unix file system using shell commands mkdir , rmdir , mv , rm , and cp view the content of the file using cat , more or less manage the permission of a file using chmod perform standard input/output redirection with < and >","title":"Unix CLI: The Essentials"},{"location":"unix-essentials.html#unix-directory","text":"Unix organizes files according to a directory structure. The following shows an example. This structure is also known as a directory tree . There are two important directories that you need to know.","title":"Unix Directory"},{"location":"unix-essentials.html#root-directory","text":"The root directory is the directory at the top of the directory tree 1 . It is simply referred to as / , without any name. Under the root directory are many other systems directory, which a casual user does not normally need to (and have no permission to) modify.","title":"Root Directory"},{"location":"unix-essentials.html#home-directory","text":"Each user has his/her own home directory. The above figure shows where the home directory of the user ooiwt resides in the directory tree. The user ooiwt may create files or directories in his/her home directory, but not elsewhere unless permission is given. The home directory is referred to with the symbol ~ in bash . Sometimes we add the username behind ~ to indicate the home directory of the other user. E.g., ~bob means the home directory of a user named bob .","title":"Home Directory"},{"location":"unix-essentials.html#current-working-directory","text":"A user can navigate around the directory tree. The current working directory is the directory that the user is currently in. In contrast to the root and home directory, which are fixed 2 , the current working directory changes as the user moves around. Knowing the current working directory is important since this is the default location in the directory tree a command executes. As such, many systems by default display the current working directory as part of the bash command prompt. The current working directory is referred to with the symbol . in bash .","title":"Current Working Directory"},{"location":"unix-essentials.html#parent-directory","text":"The parent directory is directory one layer up from the current directory. The parent directory is referred to with the symbol .. in bash . To summarize, here are the short form representations: Symbol Meaning / the root directory ~ the home directory . the current working directory .. the parent directory","title":"Parent Directory"},{"location":"unix-essentials.html#specifying-a-path","text":"To specify a directory or a file in the Unix directory tree, we can use either the absolute path or the relative path .","title":"Specifying a Path"},{"location":"unix-essentials.html#absolute-path","text":"The absolute path is constructed as follows, starting from the root of the directory structure, find a path (a sequence of directories) to the location that you want to specify, then concatenate the names of the directories together, separated by the forward-slash / . This is a similar notation used for Web site URLs so you should already be familiar with it. For instance, the path /home/o/ooiwt is the absolute path of the directory named ooiwt in the figure above. An absolute path is independent of the current working directory and always start with / or ~","title":"Absolute path"},{"location":"unix-essentials.html#relative-path","text":"The relative path is dependent on the current working directory. To refer to another location, start from the current directory, and find a path (a sequence of directories) to the location that you refer to. When we go up a tree, we use .. to represent the directory. For example, referring to the figure above, if we are in the directory /home/b , and we wish to refer to /home/o/ooiwt , we can use the relative path ../o/ooiwt . If we wish to refer to /home/b/bob , we can use the relative path bob . A relative path never starts with / .","title":"Relative path"},{"location":"unix-essentials.html#directory-related-commands","text":"Now, let's take a look at some basic commands available in bash that deals with navigation and directories.","title":"Directory-related Commands"},{"location":"unix-essentials.html#pwd-print-current-working-directory","text":"pwd shows you which directory you are currently in. Type pwd into the command prompt, and it will print the absolute path to your current working directory. For instance, Suppose you are in /home/o/ooiwt , entering 1 pwd will give the output 1 /home/o/ooiwt","title":"pwd: Print Current Working directory"},{"location":"unix-essentials.html#ls-list-content-of-a-directory","text":"The ls list the content in the current working directory. Rule of Silence Unix follows the economical rule of silence : programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program. So, if ls has nothing to list, it will list nothing (as opposed to, say, printing \"This is an empty directory.\")","title":"ls: LiSt content of a directory"},{"location":"unix-essentials.html#mkdir-make-a-subdirectory","text":"The mkdir command creates a subdirectory with the given name in the current directory. In the example below, we assume that we start with an empty directory. 1 2 3 4 5 6 $ ls $ mkdir workshop $ ls workshop $ ls -F workshop/ Here, we create a directory called workshop . Now, when we ls , you can see the directory listed. You may also use ls -F for more information ( -F is one of the many options / flags available for the ls command. To see a complete list of the options, refer to the man pages, i.e., man ls .) The slash / beside the filename tells you that the file is a directory. A normal file does not have a slash beside its name when \"ls -F\" is used. You may also use the ls -l command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification. Use Up Arrow for Command History bash maintains a history of your previously executed commands, and you may use the Ctrl + P (previous) and Ctrl + N (next) to go through it. Press the Ctrl + P until you find a previously executed command. You may then press Enter to execute it or edit the command before executing it. This is handy when you need to repeatedly execute a long bash command.","title":"mkdir: MaKe a subDIRectory"},{"location":"unix-essentials.html#cd-change-directory","text":"To navigate in the directory tree, changing the current working directory from one to another, we use the cd command. 1 2 3 4 5 $ pwd /home/o/ooiwt $ cd workshop $ pwd /home/o/ooiwt/workshop Suppose our starting working directory is /home/o/ooiwt , after we cd into workshop , the current working directory becomes /home/o/ooiwt/workshop . Note that cd can take in either an absolute path or a relative path. The example above takes in a relative path as the argument. As mentioned in \" Unix CLI: Background \", it is common to include the current working directory into the shell's prompt. So, you may see your command prompt updated to include the new working directory. Entering cd alone (without argument) brings you back to your home directory.","title":"cd: Change Directory"},{"location":"unix-essentials.html#rmdir-remove-a-subdirectory","text":"rmdir removes a subDIRectory in the current directory -- note that a directory must be empty before it can be removed. The command 1 $ rmdir workshop will remove the directory that you just created.","title":"rmdir: ReMove a subDIRectory"},{"location":"unix-essentials.html#file-management","text":"This note assumes that you are familiar with navigation with the Unix directory structure. We will now learn some commands to help us deal with files. Let's recreate the workshop directory in case you have already deleted it with the rmdir at the end of the last unit. 1 2 3 $ mkdir -p workshop $ cd workshop $ ls All of the above commands should complete successfully and silently . Let's populate the directory with a new file. Cut-and-paste the command below into the command prompt : 1 wget https://raw.githubusercontent.com/nus-unix-workshop/2021-s1/master/test.txt You should see a file being downloaded and saved with an output similar to below: 1 2 3 4 5 6 7 8 9 10 --2020-07-27 15:26:49-- https://raw.githubusercontent.com/nus-unix-workshop/2021-s1/master/test.txt Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 151.101.0.133, 151.101.64.133, 151.101.128.133, ... Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.0.133|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 64 [text/plain] Saving to: \u2018test.txt\u2019 test.txt 100%[======================>] 64 --.-KB/s in 0s 2020-07-27 15:26:50 (2.35 MB/s) - \u2018test.txt\u2019 saved [64/64] Now run ls , and you should see that ls returns test.txt as the content of the current working directory. 1 2 $ ls test.txt","title":"File Management"},{"location":"unix-essentials.html#cp-copy-files","text":"Now let's try to copy this file to another name. 1 2 3 $ cp test.txt foo.txt $ ls test.txt foo.txt The command above copies the file test.txt into foo.txt . If you want to copy the whole directory, use -r flag, where r stands for copying recursively. Now let's create another directory called copy . 1 2 3 4 $ cd .. $ mkdir copy $ cd copy $ ls Run pwd to double-check that you are in the directory called copy that is at the same level as workshop . Now, we are going to use cp with the -r flag, to copy recursively the whole of workshop directory over. 1 $ cp -r ../workshop . The command cp takes in two arguments, the first is the source, and the second is the destination. Note that we use . above to indicate that we wish to copy the whole sub-tree of workshop over the current directory. The command should complete without any message. Upon completion, you can run ls to double-check that the workshop directory exists under workshop . !!! Warning: cp Overwrites If there is an existing file with the same name, cp will overwrite the existing file without warning.","title":"cp: CoPy files"},{"location":"unix-essentials.html#mv-move-or-rename-files","text":"Now, let's change directory back to workshop . 1 $ cd ../workshop and use the mv command to rename foo.txt into bar.txt . 1 2 3 4 5 $ ls foo.txt test.txt $ mv foo.txt bar.txt $ ls bar.txt test.txt As you can see above, just like cp , mv takes in two arguments, the first is the source and the second is the destination. If the destination of mv is a directory, however, instead of renaming, the mv commands move the source to the destination directory. 1 2 3 4 5 $ ls bar.txt test.txt $ mv ../copy/workshop/foo.txt . $ ls bar.txt foo.txt test.txt Here, you can see that we have moved foo.txt over to the current directory. !!! Warning: mv Overwrites If there is an existing file with the same name, mv will overwrite the existing file without warning. mv comes with a -i flag that interactively asks you if you are sure if you want to overwrite a file. It is a good idea to always run mv -i . Hit Y to continue overwriting the existing file. You can look up on the Internet on how to make -i the default using alias command in .bashrc . Use Tab for Name Completion If you have a very long file name, you may use the bash auto-completion feature to reduce typing. For instance, you may type: 1 $ mv t and press the Tab key, bash will complete the filename for you if there is only one filename with the prefix \"t\". Otherwise, it will fill up the filename to the point where you need to type in more characters for disambiguation. The Tab key can also complete the name of a command.","title":"mv: MoVe or rename files"},{"location":"unix-essentials.html#rm-remove-files","text":"We can use rm to remove files. Be careful with this command -- files deleted cannot be restored. There is no trash or recycled bin like in Mac or Windows. 1 2 3 4 5 $ ls bar.txt foo.txt test.txt $ rm foo.txt $ ls bar.txt test.txt rm -rf While the Unix command line provides lots of flexibility and power, with great power comes great responsibility. Some of the commands are extremely dangerous. rm -rf * is the most famous one. The notation * refers to all files, and the flag -f means forceful deletion (no question asked!), and -r means remove recursively everything under the current directory tree. Accidentally running this command has ruined many lives. Read more here rm comes with a -i flag that interactively asks you if you are sure if you want to delete a file. It is a good idea to always run rm -i . 1 2 $ rm -i bar.txt rm: remove regular file 'bar.txt'? Type y or n to answer yes or no respectively.","title":"rm: ReMove files"},{"location":"unix-essentials.html#cat-catenate-file-content-to-screen","text":"To quickly take a look at the content of the file, use the cat command. 1 2 $ cat test.txt This is a test file for learning Unix file management commands. less is a variant of cat that includes features to read each page leisurely and is useful for long files. 1 $ less test.txt In less , use <space> to move down one page, b to move Back up one page, and q to Quit.","title":"cat: CATenate file content to screen"},{"location":"unix-essentials.html#man-online-manual","text":"An online help facility is available in Unix via the man command ( man stands for MANual). To look for more information about any Unix command, for example, ls , type man ls . Type man man and refer to Man Pages to find out more about the facility. To exit man , press q .","title":"man: Online MANual"},{"location":"unix-essentials.html#file-permission-management","text":"File permissions determine who can do what to a file. Typically, you do not need to fiddle with the file permission, but when you need to, it is usually for an important reason and it is critical to do it right.","title":"File Permission Management"},{"location":"unix-essentials.html#the-what-of-file-permissions","text":"Let's look at what you can do to a file first. Unix file permissions allow control of three actions: r (read), w (write) and x (execute). These permission settings allow the following different actions to be done for regular files and directories. permission effect on file effect on directory r reading the content of a file read the names of the files in the directory w writing into a file create/delete/rename files in the directory x executing a file access contents and meta-info (size, creation time) of files in the directory These three actions can be controlled independently. The permissions on a file can be expressed in two ways: using symbolic notation. For instance, rwx , r-x , -wx , where a - means that the corresponding permission is not given (in the order of r , w , x ). using a numerical notation. This notation uses a digit between 0 and 7, which is computed as a sum of the individual digit representing the permissions: r is represented with 4, w is represented with 2, and x is represented with 1. For instance, r-x has a numerical representation of 5, and -wx has a numerical representation of 3.","title":"The What of File Permissions"},{"location":"unix-essentials.html#the-who-of-file-permissions","text":"Unix divides the users into three classes: u is the u ser who owns the file; g refers to the users in the same g roup as the user; and o are all the o ther users. The permissions can be controlled separately for these classes of users. The permission notation simply concatenates the file permissions of each class of users together, in the order of u , g , and o . For instance, the permission of 644, or rw-r--r-- , on a file means that: the owner can read and write the group users can only read all the other users can only read","title":"The Who of File Permissions"},{"location":"unix-essentials.html#checking-file-permission","text":"You can view the permission of a file by using the ls -l command ( l for long format): 1 2 $ ls -l test.txt -rw-r--r--@ 1 ooiwt staff 64 Jul 28 09:52 test.txt Ignoring the first - and the last @ , you can see that the permission of test.txt is 644.","title":"Checking file permission"},{"location":"unix-essentials.html#the-chmod-command","text":"You can use chmod command to change the permissions of a file or a directory. For instance, 1 2 3 $ chmod 666 test.txt $ ls -l test.txt -rw-rw-rw-@ 1 ooiwt staff 64 Jul 28 09:52 test.txt would change add the permission w to both group and other users 1 . An alternative way is to just specify the changes. To remove the write permission from others, you can write: 1 2 3 $ chmod o-w test.txt $ ls -l test.txt -rw-rw-r--@ 1 ooiwt staff 64 Jul 28 09:52 test.txt","title":"The chmod command"},{"location":"unix-essentials.html#common-scenarios-for-chmod","text":"Here are some scenarios where you might need to use the chmod command: If you use the SoC Unix server to do your homework, you should prevent the directory that stores your homework from being accessible by other users. Make sure that your homework directory as the permission of 700 . If you download a file from the Internet and you do not have the permission to read it, you should do a u+r to give yourself the read permission. A program should have execution permission to run. If you have a script or an executable file that you can't run, give yourself the execution permission u+x .","title":"Common Scenarios for chmod"},{"location":"unix-essentials.html#standard-inputoutput","text":"","title":"Standard Input/Output"},{"location":"unix-essentials.html#history","text":"Two of the design decisions of Unix that lead to its simplicity are the decisions to (i) decouple the physical input/output devices from the programs, allowing programs written for Unix to read from abstract input and output devices; and (ii) make all programs read and write from these abstract input and output devices by default. Before Unix, the older operating systems often require programmers to painstakingly set up connections to the teletype machines and other devices for reading inputs and printing outputs. With Unix, programmers can now focus on solving the tasks at hand and let Unix takes care of the input and output. The two abstract devices that Unix provides are called standard input and standard output . By default, the standard input refers to the keyboard and the standard output is the terminal .","title":"History"},{"location":"unix-essentials.html#examples-using-cat-and-wc","text":"Let's look at these concepts closer, by examining some examples. Remember cat ? The cat command takes in a filename and it prints the content of the file to the standard output. 1 2 $ cat test.txt This is a test file for learning Unix file management commands. If no filename is given, cat by default try to read from the standard input. Try running: 1 $ cat You will see that the command is waiting for you to type in something. Type in anything, as soon as you press Enter , cat is going to read in the text from the standard input, as if it is the content of a file, and then prints the content to the standard output. You can keep typing, supplying text to cat , or you can type Ctrl + D to send the end-of-input command to cat . Let's look at another command, wc . wc is a utility that counts the number of lines, words, characters. If we call wc and supply it a file name, it will count the number of lines, words, and characters in that given file. 1 2 $ wc test.txt 1 11 64 test.txt The output means that there is 1 line, 11 words, and 64 characters in the file test.txt . But if you do not pass in any file name, wc is going to read in the text from the standard input, as if it is the content of a file, and prints the three counters to the standard output. Go ahead and try: 1 $ wc You will see that the wc command is waiting for you to type in something. Type in a few sentences, you can hit Enter for a new line. When you are done, type Ctrl + D . wc will count the number of lines, words, and characters for the text that you just entered.","title":"Examples using cat and wc"},{"location":"unix-essentials.html#output-redirection","text":"By defining two abstract input and output devices (or channels), Unix frees the programmers from worrying about where to read the input from and write the output to. Most of the time, we can write the output of the program to the standard output. In instances where we need to write the output to another location, we can just redirect the output. The operators > and >> are used to redirect the standard output to a file. The difference is that > will overwrite the given file, while >> will concatenate into the given file. For example: 1 2 3 $ wc test.txt > test.count $ cat test.count 1 11 64 test.txt The first command redirects the output from wc to a file named test.count , so you do not see anything printed to the output anymore. We can check by running cat on the new file test.count -- indeed the original output from wc is now stored in the file test.count . If we repeat the command wc test.txt > test.count again, you can see that the file has been overwritten with the output from wc again. But if we replace > with >> , a new line is concatenated into test.count . So the file now has two lines. 1 2 3 4 5 6 7 $ wc test.txt > test.count $ cat test.count 1 11 64 test.txt $ wc test.txt >> test.count $ cat test.count 1 11 64 test.txt 1 11 64 test.txt","title":"Output Redirection"},{"location":"unix-essentials.html#input-redirection","text":"The operator < is used to redirect a file into the standard input. So, instead of reading from the keyboard, we can now read from a file. Commands such as cat and wc already support from a file directly, so there is no difference in terms of functionality to run the commands by passing in the file name, or by using the < operator. 1 2 3 4 5 6 7 8 $ wc test.txt 1 11 64 test.txt $ wc < test.txt 1 11 64 $ cat test.txt This is a test file for learning Unix file management commands. $ cat < test.txt This is a test file for learning Unix file management commands. Note the slight difference in the output format of the second wc above -- it no longer prints the file name since from wc points of view, it is read from the standard input and not from a file, so it is not aware of the file named test.txt In most CS programming assignments, however, to keep things simple, you will be asked to read from the standard input only, so the < is a great time-saver -- you do not have to repeatedly type in the same input data over and over from the keyboard. You can just save the input data in a file, then redirect it to standard input with the < operator.","title":"Input Redirection"},{"location":"unix-essentials.html#other-useful-online-tools","text":"explainshell explain each shell command for you Giving write permission to other users is a security risk and you should not do this unless you know what you are doing. \u21a9 \u21a9 Not exactly true -- since Unix is designed to be flexible, even the root and the home directory can be changed! But let's not worry about that for now since there is no good reason to do that as a beginner. \u21a9","title":"Other Useful Online Tools"},{"location":"slides/index.html","text":"How to create slides with markdown and remark.js Slides are separated by: 1 --- For title slides or slides with a single statement/keyword, use 1 2 --- class: middle,center For title with bullet points, use 1 2 --- class: middle If the code is too long, try to make the content wider 1 2 --- class: wide If text or code are too tall to fit, wrap them with .small[ and ] 1 2 3 .small[ content here ] For something even smaller, use .smaller[..] or .tiny[..] . To insert image, 1 ![text](image.jpg) with scale 1 ![:scale 50%](image.jpg) For background image (fits the whole slide) Add this just after the class: 1 background-image : url ( image . png )","title":"Index"},{"location":"slides/index.html#how-to-create-slides-with-markdown-and-remarkjs","text":"","title":"How to create slides with markdown and remark.js"},{"location":"slides/index.html#slides-are-separated-by","text":"1 ---","title":"Slides are separated by:"},{"location":"slides/index.html#for-title-slides-or-slides-with-a-single-statementkeyword-use","text":"1 2 --- class: middle,center","title":"For title slides or slides with a single statement/keyword, use"},{"location":"slides/index.html#for-title-with-bullet-points-use","text":"1 2 --- class: middle","title":"For title with bullet points, use"},{"location":"slides/index.html#if-the-code-is-too-long-try-to-make-the-content-wider","text":"1 2 --- class: wide","title":"If the code is too long, try to make the content wider"},{"location":"slides/index.html#if-text-or-code-are-too-tall-to-fit-wrap-them-with-small-and","text":"1 2 3 .small[ content here ]","title":"If text or code are too tall to fit, wrap them with .small[ and ]"},{"location":"slides/index.html#for-something-even-smaller-use-smaller-or-tiny","text":"","title":"For something even smaller, use .smaller[..] or .tiny[..]."},{"location":"slides/index.html#to-insert-image","text":"1 ![text](image.jpg) with scale 1 ![:scale 50%](image.jpg)","title":"To insert image,"},{"location":"slides/index.html#for-background-image-fits-the-whole-slide","text":"Add this just after the class: 1 background-image : url ( image . png )","title":"For background image (fits the whole slide)"}]}